[{"title":"C/C++代码扩张","url":"/2020/06/15/C-C-%E4%BB%A3%E7%A0%81%E6%89%A9%E5%BC%A0/","content":"编译器的编译过程，可以粗略的分为前端和后端，如下图所示:\n\n除了使用反汇编研究编译器的最终结果外，也可以查看编译器生成的AST树表示。AST树是编译器前端所产生的最终代码表现形式。\n下面是主流编译器clang和gcc生成AST树的方法:\nAST in GCC\ngcc -fdump-tree-all main.c\n\n\ng++ -fdump-tree-all main.cpp\n\n关于GCC中AST树生成的更多选项，参考这里\nAST in clang\nclang -Xclang -ast-print -fsyntax-only main.c\n\n关于clang中AST树生成的更多选项，参考这里\n","tags":["C","C++"]},{"title":"C/C++中的内存泄露检测","url":"/2020/06/25/C-C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/","content":"内存泄露在理解内存泄露前，先简要讲下C/C++的内存模型。可执行文件使用的内存，粗略的可以分为由开发者主动支配以及由程序被动分配。举个简单的例子，全局变量以及局部变量的存储，就是由编译器编译器时候规划好的，通过malloc/new接口获得的内存则是从堆中获得的，由开发者来通过free接口释放。\n内存泄露，即开发者从堆中获得的内存，用完之后没有还给系统，从而引起了有效内存减少。\n检测内存的泄露的思路大致有两种，他们之间的区别，在于检查的层面。\n实现自己的malloc/new/free接口通过宏定义或者GCC的wrapper参数，可以取代系统的相关实现。在自己的实现中，记录下malloc/new/free接口的调用信息，比如指向内存的指针数量，分配内存的大小，是否被释放，接口的调用位置等等。依据这一原理实现的关键在于，能正确计算出什么时候应该释放内存，比如已经没有有效指针指向内存，比如释放内存的大小与申请内存大小不一等等。\n使用这一原理的工具，有Dmalloc\n使用虚拟机来检测内存泄露另一个更加行之有效，也更加耗费大的方法，则是通过虚拟机。即通过专门的虚拟机程序，在程序的实际运行过程中，实时检测内存的使用情况。\n使用这一原理的工具，有valgrind\n无论哪种办法，本质都是通过记录额外信息来实现的，区别在于记录信息的层面，是可执行程序本身，或者由系统来记录。，\n常见的内存泄露场景\n未释放内存，又申请了新内存char* str &#x3D; new char[100];str &#x3D; new char [150];delete[] str;\n局部变量被销毁后，指向的内存未被释放\n\nvoid test()&#123;    char* lo &#x3D; new char[100];    return;&#125;\n\n参考\nMemory Leak Detectors Working Principle(StackOverFlow)\n\nHow to find memory leak in a C++ code/project?(StackOverFlow)\n\n\n","tags":["C","C++","Memory"]},{"title":"C++中全局对象的初始化","url":"/2020/06/25/C-%E4%B8%AD%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"全局对象初始化查看如下C++代码：\n#include &lt;cstdio&gt;class A &#123;public:    int val;    A() &#123;        printf(&quot;construct ok \\n&quot;);    &#125;&#125;;A g_al;int main()&#123;    return 0;&#125;\n\n这段代码的运行结果是对象A的构造函数被调用，串口输出”construct ok”。根据全局对象的初始化规则，这个调用是发生在main函数之前的，而且可以是多个函数依次调用。那么，这种调用时如何实现的？\n通过gcc生成arm64汇编，汇编代码如下:\n\t.arch armv8-a\t.file\t&quot;main.cpp&quot;\t.text\t.section\t.rodata\t.align\t3.LC0:\t.string\t&quot;construct ok &quot;\t.section\t.text._ZN1AC2Ev,&quot;axG&quot;,@progbits,_ZN1AC5Ev,comdat\t.align\t2\t.weak\t_ZN1AC2Ev\t.type\t_ZN1AC2Ev, %function_ZN1AC2Ev:.LFB1:\t.cfi_startproc\tstp\tx29, x30, [sp, -32]!\t.cfi_def_cfa_offset 32\t.cfi_offset 29, -32\t.cfi_offset 30, -24\tadd\tx29, sp, 0\t.cfi_def_cfa_register 29\tstr\tx0, [x29, 24]\tadrp\tx0, .LC0\tadd\tx0, x0, :lo12:.LC0\tbl\tputs\tnop\tldp\tx29, x30, [sp], 32\t.cfi_restore 30\t.cfi_restore 29\t.cfi_def_cfa 31, 0\tret\t.cfi_endproc.LFE1:\t.size\t_ZN1AC2Ev, .-_ZN1AC2Ev\t.weak\t_ZN1AC1Ev\t.set\t_ZN1AC1Ev,_ZN1AC2Ev\t.global\tg_al\t.bss\t.align\t3\t.type\tg_al, %object\t.size\tg_al, 4g_al:\t.zero\t4\t.text\t.align\t2\t.global\tmain\t.type\tmain, %functionmain:.LFB3:\t.cfi_startproc\tmov\tw0, 0\tret\t.cfi_endproc.LFE3:\t.size\tmain, .-main\t.align\t2\t.type\t_Z41__static_initialization_and_destruction_0ii, %function_Z41__static_initialization_and_destruction_0ii:.LFB4:\t.cfi_startproc\tstp\tx29, x30, [sp, -32]!\t.cfi_def_cfa_offset 32\t.cfi_offset 29, -32\t.cfi_offset 30, -24\tadd\tx29, sp, 0\t.cfi_def_cfa_register 29\tstr\tw0, [x29, 28]\tstr\tw1, [x29, 24]\tldr\tw0, [x29, 28]\tcmp\tw0, 1\tbne\t.L6\tldr\tw1, [x29, 24]\tmov\tw0, 65535\tcmp\tw1, w0\tbne\t.L6\tadrp\tx0, g_al\tadd\tx0, x0, :lo12:g_al\tbl\t_ZN1AC1Ev.L6:\tnop\tldp\tx29, x30, [sp], 32\t.cfi_restore 30\t.cfi_restore 29\t.cfi_def_cfa 31, 0\tret\t.cfi_endproc.LFE4:\t.size\t_Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii\t.align\t2\t.type\t_GLOBAL__sub_I_g_al, %function_GLOBAL__sub_I_g_al:.LFB5:\t.cfi_startproc\tstp\tx29, x30, [sp, -16]!\t.cfi_def_cfa_offset 16\t.cfi_offset 29, -16\t.cfi_offset 30, -8\tadd\tx29, sp, 0\t.cfi_def_cfa_register 29\tmov\tw1, 65535\tmov\tw0, 1\tbl\t_Z41__static_initialization_and_destruction_0ii\tldp\tx29, x30, [sp], 16\t.cfi_restore 30\t.cfi_restore 29\t.cfi_def_cfa 31, 0\tret\t.cfi_endproc.LFE5:\t.size\t_GLOBAL__sub_I_g_al, .-_GLOBAL__sub_I_g_al\t.section\t.init_array,&quot;aw&quot;,%init_array\t.align\t3\t.xword\t_GLOBAL__sub_I_g_al\t.ident\t&quot;GCC: (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;\t.section\t.note.GNU-stack,&quot;&quot;,@progbits\n\n关键的汇编代码是以下几部分；\n构造函数的具体实现如下：\n.LC0:\t.string\t&quot;construct ok &quot;\t.section\t.text._ZN1AC2Ev,&quot;axG&quot;,@progbits,_ZN1AC5Ev,comdat\t.align\t2\t.weak\t.\t.type\t_ZN1AC2Ev, %function_ZN1AC2Ev:.LFB1:\t.cfi_startproc\tstp\tx29, x30, [sp, -32]!\t.cfi_def_cfa_offset 32\t.cfi_offset 29, -32\t.cfi_offset 30, -24\tadd\tx29, sp, 0\t.cfi_def_cfa_register 29\tstr\tx0, [x29, 24]\tadrp\tx0, .LC0\tadd\tx0, x0, :lo12:.LC0\tbl\tputs\tnop\tldp\tx29, x30, [sp], 32\t.cfi_restore 30\t.cfi_restore 29\t.cfi_def_cfa 31, 0\tret\t.cfi_endproc\n\n梳理汇编中的bl指令，可以得出以下的调用过程：\n_GLOBAL__sub_I_g_al -&gt; _Z41__static_initialization_and_destruction_0ii -&gt; _ZN1AC1Ev(_ZN1AC2Ev)\n其中_ZN1AC1Ev是一个弱符号，最终解析成_ZN1AC2Ev，即class A的构造函数\n.weak\t_ZN1AC1Ev.set\t_ZN1AC1Ev,_ZN1AC2Ev\n\n那现在问题就变成_GLOBAL__sub_I_g_al是谁调用的，查看汇编里的相关信息，如下：\n.LFE5:\t.size\t_GLOBAL__sub_I_g_al, .-_GLOBAL__sub_I_g_al\t.section\t.init_array,&quot;aw&quot;,%init_array\t.align\t3\t.xword\t_GLOBAL__sub_I_g_al\t.ident\t&quot;GCC: (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;\t.section\t.note.GNU-stack,&quot;&quot;,@progbits\n\n可以发现，_GLOBAL__sub_I_g_al存在一个单独的，名为”init_array”的section中。\n关于这个section，ARM的官方文档中，描述如下:\n\nThe C++ Standard places certain requirements on the construction and destruction of objects with static storage duration.\n\n\nThe ARM C++ compiler uses the .init_array area to achieve this. This is a const data array of self-relative pointers to functions.\n\n\nThe linker collects each .init_array from the various translation units together. It is important that the .init_array is accumulated in the same order.\n\n\nThe library routine _cpp_initialize__aeabi is called from the C library startup code, __rt_lib_init, before main. _cpp_initialize__aeabi walks through the .init_array calling each function in turn. On exit, __rt_lib_shutdown calls __cxa_finalize.\n\n\nUsually, there is at most one function for T::T(), mangled name _ZN1TC1Ev, one function for T::~T(), mangled name _ZN1TD1Ev, one sti function, and four bytes of .init_array for each translation unit. The mangled name for the function f() is _Z1fv. There is no way to determine the initialization order between translation units.\n\n\nFunction-local static objects with destructors are also handled using __aeabi_atexit.\n\n\n.init_array sections must be placed contiguously within the same region for their base and limit symbols to be accessible. If they are not, the linker generates an error.\n\n查看init_array里的信息通过以下命令，可以解析出具体调用的函数信息：\n\nobjdump -D -j .init_array \n\n在我的环境中，输出如下:\na.out:     file format elf64-littleaarch64Disassembly of section .init_array:0000000000010d78 &lt;__frame_dummy_init_array_entry&gt;:   10d78:\t00000770 \t.word\t0x00000770   10d7c:\t00000000 \t.word\t0x00000000   10d80:\t000007c0 \t.word\t0x000007c0   10d84:\t00000000 \t.word\t0x00000000\n\n通过以下命令，将具体的地址，解析成相应的函数符号:\n\naddr2line 0xc1000a68 -e \n\n在我的环境中，输出如下:\n&#x2F;tmp&#x2F;tmp.KS3wdL1X4n&#x2F;main.cpp:16\n\n需要注意的是，这部分信息属于调试信息，编译的时候，加上”-g”，编译器才会生成这些额外信息。\n参考\nWhat goes to the __init_array?(StackOverflow)\nC++ initialization, construction and destruction(Arm)\n\n","tags":["C++","Class"]},{"title":"C语言发展史及标准库梳理","url":"/2019/12/02/C%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8F%B2%E5%8F%8A%E6%A0%87%E5%87%86%E5%BA%93%E6%A2%B3%E7%90%86/","content":"前言本文主要内容来自网络上公开的资源，来源我贴在了最后。\nC语言发展历史简单的说，C语言是为了开发Unix系统而出现的，C语言最初的开发者是Dennis MacAlistair Ritchie和Kenneth Lane Thompson。\n1973年，Unix系统的核心正式采用C语言改写。\nC语言发展至今，按时间先后，使用的标准以及主要特性如下。\nK&amp;R C1975年，Brian Wilson Kernighan和Dennis MacAlistair Ritchie合作编写了一本书 《The C Programming Language》。书里介绍的C语言标准，被称为 K&amp;R C。\n书中介绍的C语言特性主要包括：\n\n标准I/O库\nstruct 类型\nlong int 类型\nunsigned int 类型\n把运算符 =+和=-改为+=和-=，以避免编译器在处理时产生混淆\n\n\n\nC89(ANSI C)1989年，C语言被ANSI(美国国家标准协会)标准化，编号为ANSI X3.159-1989，因此这个版本的C语言既被成为C89，也被成为ANSI C。\nC89引入的C语言特性主要包括：\n\nvoid函数\n函数返回struct或者union类型\nvoid *数据类型\n\n\n\nC90(ISO C)1990年，ISO(国际标准组织)开始成立工作组，来制定国际标准的C语言规范，ANSI随之接受ISO的标准，并宣布不再发展新的C语言标准。ISO发布标准，在ANSI C的基础上进行了改进，被称之为C90，或者ISO C。\nC90对C语言的改进包括：\n\n增加了标准库\n新的预处理命令和特性\n函数原型允许在函数申明中指明参数类型\n一些关键字，包括const、volatile与signed\n宽字符、宽字符串与多字节字符\n对约定规则、声明和类型检查的许多小改动与澄清\n\n1994年， ISO的WG14工作组，又对1985年颁布的标准(应该是C++标准)做了两处技术修订和一个补充，主要包括：\n\n3个标准库头文件iso646.h、wctype.h和wchar.h\n几个新记号与预定义宏，用于对国际化提供更好的支持\nprintf/sprintf函数一系列新的格式代码\n大量的函数和一些类型与常量，用于多字节字符和宽字节字符\n\n\n\nC991994年，ISO对C语言的修订和补充，引出了ISO 9899:1999的发表，这一标准又被成为C99。\nC99引入的特性包括：\n\n增加了对编译器的限制，比如源代码每行要求至少支持到4095字节，变量名函数名的要求至少到63字节（extern要求支持到31字节）\n\n增强了预处理功能，包括\n\n宏支持可变参数，即#define Macro(…) VA_ARGS\n使用宏的时候，允许省略参数，被省略的参数将被扩展成空串\n支持//开头的单行注释\n\n\n增加了新关键字restrict, inline, _Complex, _Imaginary, _Bool。支持long long, long double _Complex, float _Complex等类型\n\n支持不定长的数组，即数组长度可以在运行时决定。但是，考虑到效率和实现，不定长数组不能在全局，或者struct,union中使用\n\n变量声明不必放在语句块的开头，for语句提倡写成for(int i = 0; i &lt; 100; ++i)的形式，即i只在for语句块内部有效\n\n允许采用(type_name){xx,xx,xx}类似于C++的构造函数的形式构造匿名的结构体\n\n初始化结构时，允许对特定的元素赋值，形式为\n\n\nstruct test &#123;    int a[3], b;&#125; foo[] &#x3D; &#123;    [0].a &#x3D; &#123;1&#125;,    [1].a &#x3D; &#123;2&#125;&#125;;\nstruct test &#123;    int a, b, c, d;&#125;foo &#x3D; &#123;    .a &#x3D; 1,    .c &#x3D; 3, 4,    .b &#x3D; 5&#125;;\n\n\n格式化字符串中，利用\\u支持unicode的字符\n\n支持16进制的浮点数的描述\n\nprintf/scanf的格式化增加了对long long int类型的支持\n\n浮点数的内部数据描述支持了新标准，可以使用 #pragma编译器指令指定\n\n除了已有的__line__ __file__以外，增加了 func 获取当前函数名\n\n允许编译器化简非常数的表达式\n\n修改了 /% 处理负数时的定义，这样可以给出明确的结果。在C89中 -22 / 7 = -3, -22 % 7 = -1, 或者 -22 / 7 = -4, -22 % 7 = 6。C99中明确为-22 / 7 = -3, -22 % 7 = -1，结果是确定的。\n\n取消了函数返回值默认为int的规定\n\n允许在struct的最后定义的数组不指定其长度（变长数组）\n\nconst const int i 将被当作 const int i 处理\n\n增加和修改了一些标准头文件，详情见下文对标准头文件的汇总\n\n输入输出对宽字符以及长整数等做了相应的支持\n\n\n\n\nC112011年12月8日，ISO正式发布了新的C语言标准C11，该标准早期被称为C1X，官方名为ISO/IEC 9899:2011。\nC11提高了对C++的兼容性，部分增加的特性包括：\n\n泛型宏\n\n多线程\n\n带边界检查的函数\n\n匿名结构\n\n\n\n\nC182018年6月，ISO发布了C18，官方名称为ISO/IEC 9899:2018。\n相比于C11，C18未引入新的语言特性，仅对C11进行了补充和修正。\n\n\n\nC语言标准库\n\n\n名称\n用途\n最早引入标准\n\n\n\n&lt;assert.h&gt;\n条件编译宏\nC89\n\n\n&lt;complex.h&gt;\n复数运算\nC99\n\n\n&lt;ctype.h&gt;\n字符类型判断\nC89\n\n\n&lt;errno.h&gt;\n涉及错误报告的宏\nC89\n\n\n&lt;fenv.h&gt;\n浮点数运算环境相关\nC99\n\n\n&lt;float.h&gt;\nfloat类型的限制\nC89\n\n\n&lt;inttypes.h&gt;\nint类型的格式转换\nC99\n\n\n&lt;iso646.h&gt;\n可选的运算符拼写方式\nC95\n\n\n&lt;limits.h&gt;\n基础类型大小\nC89\n\n\n&lt;locale.h&gt;\n本地化工具\nC89\n\n\n&lt;math.h&gt;\n通用的数学函数\nC89\n\n\n&lt;setjmp.h&gt;\n非本地跳转\nC89\n\n\n&lt;signal.h&gt;\n信号处理相关\nC89\n\n\n&lt;stdalign.h&gt;\nalignas和alignof 转换宏\nC11\n\n\n&lt;stdarg.h&gt;\n可变变量声明相关\nC89\n\n\n&lt;stdatomic.h&gt;\n原子操作相关\nC11\n\n\n&lt;stdbool.h&gt;\nboolean类型相关\nC99\n\n\n&lt;stddef.h&gt;\n通用的宏定义\nC89\n\n\n&lt;stdint.h&gt;\n固定长度的int类型\nC99\n\n\n&lt;stdio.h&gt;\n输入输出\nC89\n\n\n&lt;stdlib.h&gt;\n通用的工具：内存操作，程序工具，字符串转换，随机数\nC89\n\n\n&lt;stdnoreturn.h&gt;\nnoreturn 宏相关\nC11\n\n\n&lt;string.h&gt;\n字符串处理\nC89\n\n\n&lt;tgmath.h&gt;\n泛类型的数学宏相关\nC99\n\n\n&lt;threads.h&gt;\n线程库\nC11\n\n\n&lt;time.h&gt;\n时间/日期 工具\nC89\n\n\n&lt;uchar.h&gt;\nUTF-16 和 UTF-32 字符工具\nC11\n\n\n&lt;wchar.h&gt;\n拓展的多字节和宽字符工具\nC95\n\n\n&lt;wctype.h&gt;\n区分宽字符类型的函数\nC95\n\n\n\n\n参考资源\nWiki/C语言\nC语言标准库列表\n\n","tags":["C","Linux"]},{"title":"Empty struct/class in C/C++","url":"/2020/06/11/Empty-struct-class-in-C-C/","content":"问题\nC语言中，对”struct A {};”进行sizeof运算，结果应该是多少？\n\nC++中，对”class A {};”进行sizeof运算，结果应该是多少？\n\n\nC语言对empty struct的规定在标准C中，对empty struct的大小没有做出规定，该行为是未定义的。然而，gcc做了拓展，在gcc中，empty struct的sizeof结果为0，更多的信息见参考1。\n事实上，即使是gcc中，empty struct的行为还有再复杂一些，查看如下代码\n#include &lt;stdio.h&gt;struct T &#123;&#125;;int main()&#123;    struct T a, b;    struct T *pa &#x3D; &amp;a;    struct T *pb &#x3D; &amp;b;    if ((struct T *)&amp;a &#x3D;&#x3D; (struct T *)&amp;b) &#123;        printf(&quot;first is equal \\n&quot;);    &#125;    if (pa &#x3D;&#x3D; pb) &#123;        printf(&quot;second is equal \\n&quot;);    &#125;    return 0;&#125;\n输出结果是\n\nsecond is equal\n\n看起来有些无法理解，在x86的机器上，查看对应源码的汇编代码，发现第一个比较直接被视为不成立而优化掉了。也就是说，对于编译器来说，即使是空结构体，两个不同的结构体的地址也不应该相等。gcc虽然拓展了empty struct的大小定义，但是使用上仍然有些模糊，可能会有期望之外的行为发生。\nC++对empty struct/class的规定在C++11中，empty struct/class的sizeof结果是1，至于原因，stroustrup(C++之父)解释说，是为了保证new出来的不同对象之间，即使是empty class，地址也不应该相等，详细信息见参考2。\n对于大部分C++编译器来说，一般还会做一个称之为”empty base class optimization”的优化，查看如下代码\n#include &lt;iostream&gt;class T &#123;&#125;;class TT : public T &#123;    int x;&#125;;int main() &#123;    std::cout &lt;&lt; sizeof(class TT) &lt;&lt; std::endl;    return 0;&#125;\n\n输出结果是\n\n4\n\n也就是说，如果一个class继承自empty class，那么empty class多余的那个1就不会出现，以避免预期之外的行为。\n那问题来了，C++中存在sizeof为0的class吗？答案是C++标准中是不允许存在，但是在g++中，可以构造一个出来，查看如下代码\n#include &lt;iostream&gt;class T &#123;    int x[0];&#125;;int main() &#123;    std::cout &lt;&lt; sizeof(class T) &lt;&lt; std::endl;    return 0;&#125;\n\n*g++*中，输出结果为\n\n0\n\n这个行为是未定义，属于预期之外的行为。\n参考\ngcc关于empty struct的扩展\n为什么C++的empty class大小不为0\n\n","tags":["C","C++","GCC"]},{"title":"Linux下如何执行buffer中的一段代码","url":"/2020/11/23/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8Cbuffer%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/","content":"linux中，存在一个系统调用mprotect，可以修改一段内存的权限信息，一般情况下，数据段是不可以执行的，通过mprotect，可以赋予数据段以执行权限，再将一段逻辑实现拷贝到该数据段中，通过函数指针跳转，从而执行该数据段中的代码，以下为实现部分:\n两个源码文件，分别为main.c和test.S\ntest.S的内容为：\n.code64.align 0x1000.text.global test.type test, @functiontest:    pushq   %rbp    movq    %rsp, %rbp    movl    $22, %eax    popq    %rbp    ret\n\nmain.c的内容为\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys&#x2F;mman.h&gt;int test(void);int main()&#123;    int ret;    int (*p)(void);    void *code;    code &#x3D; mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (code &#x3D;&#x3D; MAP_FAILED) &#123;        printf(&quot;mmap failed, errno is %d \\n&quot;, errno);        return -errno;    &#125;    ret &#x3D; mprotect(code, 0x1000, PROT_EXEC | PROT_WRITE);    if (ret &#x3D;&#x3D; -1) &#123;        printf(&quot;mprotect failed, errno is %d \\n&quot;, errno);        return -errno;    &#125;    ret &#x3D; test();    if (ret !&#x3D; 22)        return -EINVAL;    puts(&quot;execute assembly successfully&quot;);    memcpy(code, test, 0x1000);    p &#x3D; code;    ret &#x3D; p();    if (ret !&#x3D; 22)        return -EINVAL;    puts(&quot;execute buffer successfully, end here&quot;);    return 0;&#125;\n\n编译用的cmake文件为:\ncmake_minimum_required(VERSION 3.16)project(ACM C ASM)set(CMAKE_C_STANDARD 99)set_source_files_properties(test.S PROPERTIES COMPILE_FLAGS &quot;-x assembler-with-cpp&quot;)add_executable(ACM main.c test.S)\n\n运行结果如下:\nexecute assembly successfullyexecute buffer successfully, end here\n\ngdb调试可以加入以下指令，进行查看:\ndisplay &#x2F;20i $pc","tags":["Memory","Linux","Assembly Language"]},{"title":"Flexible array in C/C++","url":"/2020/06/12/Flexible-array-in-C-C/","content":"数据结构，是数据的抽象和组织方式。对程序语言来说，数据结构是内存的解释方式。可变数组，是指大小不固定的数组。可变数组，通常是某个结构体的最后一个成员。可变数组，在通信等场景中有着大量的应用。\nISO C99中的可变数组可变数组(flexible array member)已经成为ISO C99标准的一部分，在C99的规定中，可变数组的使用存在以下限制:\n\n可变数组属于incomplete type，仅能为结构体的最后一个成员\n不能有包含可变数组成员的结构体组成的数组\n拥有可变数组成员的结构体不能作为其他结构体的成员\n拥有可变数组成员的结构体还应该拥有至少一个其他命名成员\n\n查看如下代码，C99标准中可变数组的使用\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define SIZE 100struct Pack &#123;    int num;    char data[];&#125;;int main()&#123;    struct Pack *p &#x3D; (struct Pack *)malloc(SIZE + sizeof(struct Pack));    p-&gt;num &#x3D; SIZE;    memset(p-&gt;data, 0, sizeof(char) * p-&gt;num);    free(p);    return 0;&#125;\n\n可变数组的起始地址，是通过偏移计算出来的。因此可变数组如果长度为0，本身并不占据空间。对于编译器来说，可变数组是无视越界检查的incomplete type，因此，可变数组的使用过程中，需要十分谨慎，不能引起越界访问，否则可能造成各种无法预知的问题。\n标准之前的可变数组在可变数组成为ISO C一部分之前，其使用方式通过是如下方式实现的(以下代码来自Nuttx)\n包含可变数组的结构体定义:\nstruct tmpfs_file_s&#123;  &#x2F;* First fields must match common TMPFS object layout *&#x2F;  FAR struct tmpfs_dirent_s *tfo_dirent;  struct tmpfs_sem_s tfo_exclsem;  size_t   tfo_alloc;    &#x2F;* Allocated size of the file object *&#x2F;  uint8_t  tfo_type;     &#x2F;* See enum tmpfs_objtype_e *&#x2F;  uint8_t  tfo_refs;     &#x2F;* Reference count *&#x2F;  &#x2F;* Remaining fields are unique to a directory object *&#x2F;  uint8_t  tfo_flags;    &#x2F;* See TFO_FLAG_* definitions *&#x2F;  size_t   tfo_size;     &#x2F;* Valid file size *&#x2F;  uint8_t  tfo_data[1];  &#x2F;* File data starts here *&#x2F;&#125;;\n\n大小计算方式如下\n#define SIZEOF_TMPFS_FILE(n) (sizeof(struct tmpfs_file_s) + (n) - 1)\n\n相比于ISO C99的用法，这种用法，要求可变数组的长度至少为1。因此，在计算数组长度的时候，需要减去1，以消除该成员带来的影响，使用方式上则与ISO C99上没有差异。倒不如说，正是由于C语言标准的发展滞后，才会出现这种写法，并最终发展为C语言标准的一部分。\n参考\nDCL38-C. Use the correct syntax when declaring a flexible array member\n\nArrays of Length Zero\n\n\n","tags":["C","C++","Memory"]},{"title":"[IC221]USNA/Systems Programming","url":"/2020/01/09/IC221-USNA-Systems-Programming/","content":"偶然找到一门unix课程，是由usna(美国海军学院)开设的，课程编号是IC221，质量非常高。本来是准备翻译整个系列的，但是精力有限，计划按照授课大纲写成几篇总结。\n课程主页\n内容主题以及对应地址将会记录如下：\n\nUNIX系统介绍\n\n(lecture1)  Unix 和 Linux 介绍\n(lecture2)  Unix文件系统和命令行工具\n(lecture3)  Unix设计哲学以及标准流\n\n\nC语言编程\n\n(lecture4)  格式化输入/输出和基本类型\n(lecture5)  结构，指针和数组\n(lecture6)  字符串和字符串系统库\n(lecture7)  命令行参数和二维数组\n(lecture8)  程序内存布局和动态内存\n(lecture9)  动态数组分配和数据表示\n(lecture10) 字符串和字符串系统库\n(lecture11) 用户态，内核态和系统调用\n(lecture12) 通过系统调用操作文件和设备I/O\n\n\n进程\n\n(lecture13) 进程创建和管理\n(lecture14) fork/exec/wait\n(lecture15) 进程状态和OS进程调度\n(lecture16) 终端设备和作业控制（Job Control)\n(lecture17) 进程组和终端信号\n(lecture18) 管道和文件复制\n(lecture19) 信号和信号处理\n(lecture20) 定时器，sigaction()和可重入系统调用\n\n\n文件系统\n\n(lecture21) 文件系统，内核数据结构和打开文件\n(lecture22) 文件链接：软链接/硬链接\n\n\n操作系统安全\n\n(lecture23) 设置用户/用户组权限\n(lecture24) 修改环境变量，代码注入，溢出攻击\n\n\n网络\n\n(lecture25) 网络基础/客户端服务器模型(C/S模型)\n(lecture26) scoket编程基础\n(lecture27) socket服务器\n\n\n线程\n\n(lecture28) Posix线程\n(lecture29) 锁，死锁和并发\n\n\n\n","tags":["C","Linux","USNA","IC221","UNIX","OS","Shell"]},{"title":"Weak Symbol in C/C++","url":"/2020/06/22/Weak-Symbol-in-C-C++/","content":"weak symbolweak symbol是二进制文件里的一种符号类型，与之相对的，是strong symbol。符号的类型跟代码中的声明和实现有关，查看以下代码：\n#include &lt;cstdio&gt;# define weak_alias(name, aliasname) _weak_alias (name, aliasname)# define _weak_alias(name, aliasname) \\  extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));extern &quot;C&quot; &#123;    extern void UndefinedSymbol();    void StrongSymbol()    &#123;        printf(&quot;Strong Symbol \\n&quot;);        return;    &#125;    weak_alias(StrongSymbol, WeakAliasSymbol);    int g_1;    int g_2 &#x3D; 1;&#125;int main() &#123;    StrongSymbol();    WeakAliasSymbol();    UndefinedSymbol();    return 0;&#125;\n通过以下命令得到对应的符号类型\n\ng++ -c main.cppnm main.o\n\n得到的输出为\n\nB g_1D g_2T StrongSymbolU UndefinedSymbolW WeakAliasSymbol\n\n基本涵盖了常见的符号类型:\n\ng_1 -&gt; B 表示未初始化或初始化为0的符号，存储在BSS段\ng_2 -&gt; D 表示初始化的符号，存储在DATA段\nStrongSymbol -&gt; T 表示既有声明，也有定义的函数，存储在TEXT段\nUndefinedSymbol -&gt; U 该函数仅有声明，没有定义，具体的定义推迟到链接阶段出现\nWeakAliasSymbol -&gt; W 该函数有声明，也可能存在定义，但是属于弱符号\n\n一般用法如果在一个二进制文件中，出现两个类型均为T的同名符号，就会出现”Mutiple definition”的错误。但是如果如果一个类型为W的弱符号跟一个类型为T的强符号同时出现，那么定义便由类型为T的强符号决定，这也是弱符号(weak symbol)的一般用途，即允许使用该库的开发者自定义相关实现，但同时也提供了一个默认实现。关于这一用法，可以参考这里\n更多的符号类型，参考GNU文档\n更本质的原则考虑以下情形：\n\n二进制文件中调用了某个外部接口UndefinedSymbol\n动态链接库libt1中声明了UndefinedSymbol为一个类型为T的StrongAlias符号的weak alias\n动态链接库libt2中声明了UndefinedSymbol为一个类型为T的符号，即给出了具体的定义\n二进制同时链接了libt1和libt2\n\n问题是，二进制会链接哪一个库中的UndefinedSymbol？答案是，取决于链接的顺序。\n关于这一符号解析原则的阐述，在以下的两份文档中给出了说明(见参考2和3)：\n关于符号解析的规则\n\nAnother form of simple symbol resolution, interposition, occurs between relocatable objects and shared objects, or between multiple shared objects. In these cases, when a symbol is multiply-defined, the relocatable object, or the first definition between multiple shared objects, is silently taken by the link-editor. The relocatable object’s definition, or the first shared object’s definition, is said to interpose on all other definitions. This interposition can be used to override the functionality provided by another shared object. Multiply-defined symbols that occur between relocatable objects and shared objects, or between multiple shared objects, are treated identically. A symbols weak binding or global binding is irrelevant. By resolving to the first definition, regardless of the symbols binding, both the link-editor and runtime linker behave consistently.\n\n关于链接顺序的说明\n\nSearch the library named library when linking. (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.) It makes a difference where in the command you write this option; the linker searches and processes libraries and object files in the order they are specified. Thus, foo.o -lz bar.o&#39; searches library z’ after file foo.o but before bar.o. If bar.o refers to functions in `z’, those functions may not be loaded. The linker searches a standard list of directories for the library, which is actually a file named liblibrary.a. The linker then uses this file as if it had been specified precisely by name.\n\n简单的来说，就是以最先链接到的为准。\n参考\nstrong weak symbol\nOracle Symbol Resolution\nGNU Link Options\n\n","tags":["C","C++","GCC"]},{"title":"NVDIA Steam初体验","url":"/2021/04/05/NVDIA-Steam%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"手头有台闲置的笔记本，一直在运行Linux。笔记本上有张GTX 970M的显卡，想着能不能拿来玩游戏(Apex)。问题在于：\n\nApex不支持在Linux下运行，即使是借助wine的lutris。因此，只能考虑在一台笔记本上，同时运行Linux和windows。\n因为要运行Linux，希望能把笔记本一直放在杂物间里，避免搬来搬去。\n\n对于第一个问题，有两个解决办法：\n\n使用虚拟机，如果要在虚拟机中使用显卡来获得较好的性能，可以考虑设备直通。支持这一用法的有ESIX。\n使用双系统，通过grub来解决系统间的切换。\n\n同时运行Windows和Linux使用EXSI通过设备直通来同时使用Windows和Linux安装EXSI的过程中，遇到无法找到网卡设备的问题。最后发现是ESXI内置支持的网卡驱动比较少，下载了一个别人改造过的版本，顺利安装。悲剧的是，我发现虽然GTX 970M支持设备直通，但是笔记本的bios不支持这一用法。\n使用双系统来同时使用Windows和Linux双系统的使用过程不多赘述，要点如下:\n\n先安装Windows，再安装Linux\n分区设置，将引导默认由Linux中的grub管理\n\n因为grub可以识别Windows启动项，但是Windows不能识别Linux启动项(至少我没发现办法)。\n这样做有一个局限，就是没法同时运行Linux和Windows，考虑到使用Windows的场景并不多，偶尔拿来打游戏还是能接受的。同时，还有另外一个问题。那就是如何在不去现场操作笔记本的情况下，能在双系统间进行切换？\n解决的要点如下：\n\n分别设置Windows和Linux的网卡成静态IP，同时分别打开远程桌面和sshd，保证重启后，能登录到笔记本里。\nLinux下可以直接操作grub，修改默认启动项，在Linux下，将grub默认设置为Windows，然后重启；在Windows下，将grub默认设置为Linux，然后重启。\n\n关于如何在Windows下操作grub：\nWindows下首先找到grub相应的引导分区，直接修改grub.cfg即可。\n通过NVDIA Stream来玩游戏云游戏的概念很早就出现了，毕竟，只要是使用过远程桌面，就会很自然的想到，能不能远程使用应用，尤其是游戏。当前能找到的云游戏的解决方案很多，腾讯更是几年前就推出过堡垒之夜的云端试玩。我选择了NVDIA Stream，是因为使用起来相对简单，而且我使用的是N卡，如果电脑要支持云游戏，那么我觉得显卡驱动这一层来支持是最好的。\n使用NVDIA Sream过程中，遇到一些问题：\n\nNVDIA Get Experience存在网络问题\n\n一开始是无法登陆，后来是登陆了无法跳转，最后通过某加速器加速NVDIA Get Experience解决问题。\n\n远程桌面下，无法打开NVDIA Stream\n\n这个问题，我折腾了最久。后来用了命令行版的NVDIA Stream，发现是远程桌面下不能支持NVDIA Steam。可以使用vnc之类的软件来解决。当然，也可以一次设置好，下次直接让NVDIA Stream自动启动就好。注意，只要使用过远程桌面，就会导致NVDIA Steam失效。\n\n游戏运行前，需要首先运行加速器\n\n这个问题，我暂时是手动运行解决的。我觉得，可以尝试将加速器也添加到NVDIA Steam的game list中，先运行加速器，再运行游戏，应该也是，没问题的。\n使用体验我的测试环境是千兆无线网络，基本感觉不到延迟，偶尔有网络波动，通过有线网络应该可以获得更好的游戏体验。更难得的是，moonlight不仅支持在电脑上玩云游戏，在手机上也可以运行云游戏。可以预见，云游戏在不久的未来，会越来越流行。\n","tags":["NVDIA","Cloud Game"]},{"title":"X86-64下关闭MMU","url":"/2020/11/01/X86-64%E4%B8%8B%E5%85%B3%E9%97%ADMMU/","content":"kexec X86-64下的执行过程kexec的代码是有两部分的，一部分在Linux内核中(编译时需要打开相关的编译选项)，一部分在kexec-tools中。\nkexec的流程主要分为两个部分，首先是内核加载，通过以下命令实现\ncmdline&#x3D;$(cat &#x2F;proc&#x2F;cmdline)kexec -l &#x2F;boot&#x2F;vmlinuz-linux-lts --initrd&#x3D;&#x2F;boot&#x2F;initramfs-linux-lts.img --append&#x3D;&quot;$cmdline&quot;\n-l指定了kernel的路径，–initrd指定了根文件系统路径，–append指定了cmdline参数\n接着是开始内核切换，通过以下命令实现\nkexec -e\n\n内核的执行入口为/kernel/kexec_core.c的kernel_kexec函数，详细过程如下:\n\n通过migrate_to_reboot_cpu将kexec的执行主体迁移到主核\n通过machine_shutdown发送IPI中断来关闭所有从核，从核最终会执行stop_this_cpu使cpu进入hlt状态\n通过machine_kexec使主核继续进行后续的流程\n\nmachine_kexec相关的逻辑实现位于/arch/x86/kernel/machine_kexec_64.c，详细过程如下:\n\n进行关中断，清除断点之类的环境准备工作\n将relocate_kernel函数的实现拷贝到过渡区域(关于过渡区域的说明，见下文)\n设置段寄存器，gdt表和idt表为无效状态(long mode下内存访问不涉及段机制)\n跳转进入relocate_kernel\n\nrelocate_kernel的实现是一段汇编，位于/arch/x86/kernel/relocate_kernel_64.S，relocate_kernel接受五个参数，比较重要的是两个，是一致性映射的pgt页表地址，以及处于一致性映射区域的入口地址，至于什么是一致性映射，以及如何实现一致性映射和如何使用一致性映射，见下文部分。\n需要注意的是，这个一致性映射区域的入口不是新内核，而是kexec-tools里面的一段汇编，这段汇编位于kexec-tools源码下的/purgatory/arch/x86_64/setup-x86_64.S，入口为purgatory_start(至于如何判定入口为purgatory_start，见参考2)。\n这段逻辑最后会跳转到新内核的入口中执行，从relocate_kernel开始的汇编，直到跳转到新内核入口前，主核所做的事情主要是退出long mode，关闭mmu，设置gdt表，进入protection mode，详细过程见下文。\nX86-64的CPU模式X86-64下CPU有以下几种模式:\n\nLong Mode\n64-bit mode(Long mode下的一种子模式，系统正常运行的模式)\nCompatibility mode(Long mode下的一种子模式，可运行32位程序)\n\n\nLegacy Mode\nProtected Mode(32位程序运行时的一般模式)\nVirtual-8086 Mode\nReal Mode(16位程序运行时的一般模式)\n\n\nSystem Management Mode (SMM，系统管理模式，由外设触发)\n\n模式之间的转换关系，见下图(来自AMD64 Architecture Programmer’s Manual Volume 2:System Programming):\n\nX86-64下的内存访问机制X86-64下内存机制有两个:\n\n段机制\n页机制\n\n一般情况下，段机制会首先对地址进行转换，其次才是页机制。相对应的，在不同阶段，内存地址有着不同的名称，分别为:\n\nLogical Addresses(虚拟地址)\nLinear(Virtual) Addresses(线性地址)\nPhysical Addresses(物理地址)\n\nLogical Addresses经过段机制的作用，变成Linear Addresses，Linear Addresses经过页机制的作用，变成Physical Addresses。\n内存地址，是一个相对偏移，在不同的坐标系中，同一个内存地址有着不同的偏移值。比较特殊的是物理地址(Physical Addresses)，可以认为是绝对地址(通用地址)。\n需要说明的是，段机制在64-bit mode下是没有发挥作用的，因此64-bit运行的一般情况下，虚拟地址就是线性地址。\n段机制和页机制的本质，都是对内存在不同坐标系之间进行了映射，如果这种映射是一对一的，即映射前后，没有发生变化，这种内存模式被称之为flat mode，一般用于关闭某种内存机制前后进行过渡。\n段机制段机制发挥作用，需要gdt(idt)表和段寄存器同时发挥作用，段寄存器指向gdt(idt)表中的某一项。gdt(idt)表的切换，通过lgdt(lidt)实现，lgdt(lidt)接受一个十字节的元数据，前两个字节描述表的大小，后八个字节描述表的虚拟地址。gdt(idt)表中的每一项，描述了段的基础地址，段大小，权限信息和控制信息。\n以下是一种gdt表的书写技巧，gdt表的第一项通常不用，空出第二项，两项共16个字节，前10个字节用于放置gdt表的元数据，即gdt表中放置了gdt表的描述信息(该表实现了上文所说的flat mode):\n\t.balign\t16\t.globl tr_gdttr_gdt:\t.short\ttr_gdt_end - tr_gdt - 1\t# gdt limit\t.long\tpa_tr_gdt\t.short\t0\t.quad\t0x00cf9b000000ffff\t# __KERNEL32_CS\t.quad\t0x00af9b000000ffff\t# __KERNEL_CS\t.quad\t0x00cf93000000ffff\t# __KERNEL_DStr_gdt_end:\n\n当执行完lgdt(lidt)，还需要进一步刷新段寄存器，除CS段寄存器外，都可以通过以下方式实现:\nmov 0x18, %ds\nCS段寄存器需要通过far jmp实现，需要注意的是，每个段寄存器都存在一个不可见的缓存，只有段寄存器被改变时，才会从最新的gdt(idt)表中刷新缓存，也就是说，如果只是改变了gdt(idt)表，发挥作用的仍然是原有的段表，一般情况下，在段表被刷新后，就应该及时刷新段寄存器，以防止后续进行刷新时，段表地址不可用。\nfar jmp的实现，有三种方式，分别为:\n\nlret\nlcall\nljmp\n\n以下是一种lret的示例:\nleaq\tstack_init(%rip), %rsppushq\t$0x10 &#x2F;* CS *&#x2F;leaq\tnew_cs_exit(%rip), %raxpushq\t%raxlretq\n\n页机制页机制借助pgt表实现，pgt表中存在了多重映射关系，pgt表的切换通过以下方式实现:\nmovq\t%r9, %cr3\n其中r9寄存器存放了新pgt表的物理地址。\n如何关闭MMU所谓关闭MMU，即无效化页机制，直接使用物理地址访问内存。关闭MMU，仅需要一条指令即可实现。问题在于，在该指令之前，页机制生效，在该指令之后，页机制不生效，但是，PC的值是连续自增的，因此需要在一致性映射区域中关闭MMU。在一致性映射中，虚拟地址和物理地址相等，此时关闭MMU，不会影响PC的自增。\n正常系统运行时，使用的不是一致性映射，同理，从原有的页表切换到一致性映射页表，也需要一个过渡区域。在该过渡区域中，既存在部分以前页表的映射关系(页表切换前后的指令所在函数)，也要存在一致性映射区域。\n设计上，可以直接在一致性映射页表的基础上，加上原有页表的一段映射。一致性映射的添加，Linux内核通过kernel_ident_mapping_init实现，kexec中相关实现位于/arch/x86/kernel/machine_kexec_64.c中的init_pgtable函数。\n因此，关闭MMU过程中，需要经历以下过程:\n\n跳转到过渡区域\n在过渡区域中切换一致性映射页表，并跳转到一致性映射区域\n在一致性映射区域关闭MMU\n\n如何在X86-64下关闭MMUX86-64的正常运行模式为64 bit mode，该模式下不能直接关闭MMU。按照手册的描述，Long mode下关闭MMU，需要经过以下过程:\n\n进入一致性映射区域(参考上文说明)\n设置段机制为flat mode，并且刷新段寄存器\n通过far jmp切换cpu mode为Compatibility mode\n关闭MMU\n退出long mode(此时进入protection mode)\n关闭PAE\n\n进入一致性映射区域可以参考kexec的relocate_kernel，后续流程参考kexec-tools的purgatory_start。\n参考\n符号的重定位\nA travel to the purgatory\n\n","tags":["X86","AMD","Kexec","Long mode"]},{"title":"initrd, initramfs, rootfs","url":"/2021/02/21/initrd-initramfs-rootfs/","content":"这篇博客主要阐述initrd，initramfs，rootfs之间的关系，内容主要总结自Linux(5.12)源码中的文档/Documentation/filesystems/ramfs-rootfs-initramfs.rst\nramfsramfs，就如名字所表示的那样，这是基于内存的文件系统。\nramfs and ramdiskram disk是早期Linux使用的一种机制，使用内存来模拟一个块设备，并将这个块设备挂载为文件系统。这一机制的优势在于，使用内存完全模拟了一个存储设备的行为。但是缺点也特别明显。首先是，文件系统的大小是固定的。其次是，在此类文件系统的操作过程中，存在不必要的内存拷贝行为。最严重的是，这个文件系统需要相关的驱动进行挂载和解释。\nramfs and tmpfsramfs的一个缺点就是，ramfs会一直写入内存，直到没有内存可以使用。\ntmpfs是ramfs中的一种，tmpfs的优势在于：tmpfs增加了大小的限制；允许将数据写入到交换区；普通用户也能写入tmpfs的挂载点。\nrootfsrootfs是一种特殊的ramfs实例，rootfs自2.6之后便一直存在。rootfs是无法卸载的，就像init进程无法被kill一样。大部分系统会直接通过rootfs挂载其他文件系统。如果CONFIG_TMPFS被开启，那么rootfs将使用tmpfs，而不是ramfs。如果要强制使用ramfs，就在cmdline中加入”rootfstype=ramfs”。\ninitramfs从2.6内核开始，内核都包含一个压缩的cpio文件，在内核启动的时候，这个文件会被解压成rootfs。解压之后，内核会去检查根目录下是否存在init文件，如果存在，就作为1号进程执行。这个进程负责系统剩余的拉起工作，包括寻找并挂载真正根文件设备。如果init不存在，内核会使用以前的方式，首先找到一个root分区，然后寻找类似/sbin/init作为init进程。\ninitramfs和旧的initrd区别在于：\n\ninitrd总是一个单独的文件，而initramfs可以被链接到kernel镜像中(initramfs总是存在的，initrd不是必须的)\ninitrd是特定的一个文件系统，比如ext2，因此需要kernel有相应的驱动。initramfs是一个压缩的cpio文件，解压十分容易。这部分解压代码在kernel启动之后，会被丢弃掉\ninitrd做完准备工作后，会返回kernel继续运行。initramfs一般不会返回，但是init可以挂载新的root设备，然后执行另一个init程序\n当进行root设备切换时，initrd会进行pivot_root，然后卸载ramdisk。但是initramfs是rootfs，我们可以pivot_root rootfs，也可以进行卸载。相比于删掉rootfs来释放空间，initramfs可以挂载新的root，然后执行其他的init程序\n\n","tags":["Linux","Initrd","Initramfs","rootfs"]},{"title":"嵌入式系统概述","url":"/2020/02/08/mooc-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","content":"嵌入式系统概述(中国大学Mooc)的课堂笔记\n\n\n\n嵌入式系统的定义，组成及一般开发流程目前国内普遍接受的概念[1]：嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适于应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。\n嵌入式系统的一般设计过程[1]： \n\n硬件原理图的设计\nPCB设计\n硬件制板\n硬件元器件的安装\n嵌入式操作系统的移植\n嵌入式软件设计\n\n嵌入式系统的设计，通常要考虑到实时性、可靠性、稳定性。具体的问题包括：\n\n硬件资源、运行环境和设计指标\n升级方式\n开发和测试策略\n\n嵌入式的概念，是相对于通用计算机的，当然，这种通用也是相对的，嵌入式强调的是一种专用用途，应用场景常常是资源受限的，优先考虑的也不是用户友好性，是安全性和可靠性。嵌入式系统的用途非常广，包括但不限于无人驾驶、通信设备、军事武器等等。\n\n\n嵌入式C语言编程写法及优化技巧嵌入式开发过程中，最为常用的编程语言是C语言，原因很多，很重要的一个原因，内核通常是用C语言写的。\n一般的单任务嵌入式程序典型架构是：\n\n从cpu复位时的指定地址开始执行\n跳转至汇编代码startup处执行，完成部分初始化动作\n跳转至用户主程序main执行，在main中完成：\n初始化部分硬件设备\n初始化各软件模块\n进入死循环(无线循环)，调用各模块的处理函数\n\n\n\n尽管C语言并不是一门面向对象的语言，但是，通过sturct和函数指针，仍然可以很好的模拟”类”的写法，使得写出的代码，具备很好的维护性。\n以下，是这种写法的一种实例：\n#define C_Class structC_Class A&#123;    C_Class A *A_this;    void (*foo)(C_Class A*A_this);    int (*parea)(int length, int width);    int a;    int b;&#125;;\n\n嵌入式平台中，最常用的芯片是arm系列，因此，如果需要处理一些性能敏感的场景，需要结合生成的arm汇编代码一起查看。\n尽管现在的编译器已经非常智能，能够帮助程序员处理很多情况。但是，在一些存在歧义的情况下，编译器一般会采取保守的判断，以防止程序行为超出预期。因此需要对编译器有一定的了解，了解编译器在哪些方面是保守的，了解编译器对应的处理器体系结构。\n以指针别名为例，来展示编译器的保守方面以及对应的优化策略：\n考虑以下代码\nvoid timers_v1(int *timer1, int *timer2, int *step)&#123;    *timer1 +&#x3D; *step;    *timer2 +&#x3D; *step;&#125;\n\n对应的arm汇编为\nLDR r3, [r0, #0]     --&gt; r3 &#x3D; *timer1LDR r12,[r2, #0]     --&gt; r12 &#x3D; *stepADD r3, r3, r12      --&gt; r3 +&#x3D; r12STR r3, [r0, #0]     --&gt; *timer1 &#x3D; r3LDR r0, [r1, #0]     --&gt; r0 &#x3D; *timer2LDR r2, [r2, #0]     --&gt; r2 &#x3D; *stepADD r0, r0, r2       --&gt; r0 +&#x3D; r2STR r0, [r1, #0]     --&gt; *timer2 &#x3D; r0MOV pc, r14          --&gt; return\n可以看到, step指针指向的值被取出来两次，有一次是明显多余的。出现这种情况的原因，是编译器必须考虑所有可能的情况，假设step跟timer1指向同一个地址，那么第一次运算后，timer和step的值都被更新了，所以第2次重取step的值，才能保证在这种情况下，行为也符合预期。\n但是如果程序员确定step和timer指向不同的地址，那么可以采取下面的写法，来减少一次step取值：\nvoid timers_v2(int *timer1, int *timer2, int *step)&#123;    int tmp &#x3D; *step;    *timer1 +&#x3D; tmp;    *timer2 +&#x3D; tmp;&#125;\n\n除此之外，数据结构在内存中的布局也能极大影响程序的效率，如果结构的成员变量不全是内存对齐的，那么在取值时，就需要多余的操作。\n总之，嵌入式程序的优化，是在基于对所写程序面向的场景，编译器和程序语言的了解上，使得生成的arm汇编最为精简。需要说明的是，效率最优并不总是程序首先考虑的事情，代码的可维护性以及优化所要付出的努力和优化带来的效果对比，这些都是优化前所要考虑的事情。\n\n\nLinux C的编程工具链以及构建系统嵌入式开发过程中，涉及到的编译器，调试器，构建工具等等一系列的工具，被称之为工具链。\n嵌入式系统开发中，开发环境和运行环境常常是不同架构的，因此就需要交叉编译，即在开发环境中编译出与之不同的运行环境的可执行文件。\n当前使用最为广泛的为GNU工具链，GNU支持本地程序开发，也交叉编译，即GNU工具链包括  ：\n\nGNU Tools (GNU Development Toolchains)\nGNU Tools交叉开发环境 (GNU Cross-Platform Development Toolchains)\n\n嵌入式C语言最早流行的构建系统是make，后来进一步发展出了CMake，CMake足够处理一些常见的项目场景，但在更复杂的构建场景中，比如系统的生成需要从多个仓库获取源码，进行编译链接时。对于这种复杂的场景，当前比较主流的构建系统是yocto。\n一个嵌入式系统通常由3部分构成：\n\nBootloader\n嵌入式操作系统内核\n文件系统\n\nBootloader可以分为单阶段和多阶段。多阶段的Bootloader能提供更加复杂的功能，以及更好的移植性。大多数Bootloader都有两种工作模式，分别是Bootloader自动加载操作系统运行，全程不需要用户介入，即正常工作模式;以及通过串口或者网络等方式首先下载所需文件，再进行后续引导，即下载模式，通常首次启动时使用。\n\n\n嵌入式系统书籍推荐\n嵌入式软件设计(清华大学出版社)\nARM嵌入式系统开发 - 软件设计与优化(北京航空航天大学出版社)\nLinux程序设计(人民邮电出版社)\nLinux设备驱动程序(中国电力出版社)\nLinux设备驱动开发详解(人民邮电出版社)\nProteus电子电路设计及仿真(电子工业出版社)\n\n\n\n参考\n嵌入式系统概述(中国大学MOOC)\n\n","tags":["Mooc","Note","Linux","Embeded System"]},{"title":"一行打印引出的Linux信号知识","url":"/2020/01/03/%E4%B8%80%E8%A1%8C%E6%89%93%E5%8D%B0%E5%BC%95%E5%87%BA%E7%9A%84Linux%E4%BF%A1%E5%8F%B7%E7%9F%A5%E8%AF%86/","content":"引发问题的打印\n一个正常运行的进程，在收到52号信号后，打印了”实时信号 18”，然后便异常退出了，异常退出码是180。\n问题以如下几个：\n\n进程为什么会异常退出\n18号实时信号跟52号信号有什么关系\n是什么地方打印了提示内容\n退出码180跟52有什么关系\n\n\n\n进程为什么会退出\n根据man page里的描述，信号的默认处理行为有四种，52号信号属于实时信号，一个进程收到实时信号的默认行为，就是直接终止进程。\n18号实时信号跟52号信号有什么关系\n根据man page里的描述，实时信号总共有32个，起始编号从SIGRTMIN开始，SIGRTMIN的值由Glibc决定，一般为34或35。显然，此处的52 = 34 + 18。即52号信号，是 “实时信号 18”的另一种描述。\n是什么地方打印了提示内容粗略分析，有3个地方可能打印了该内容，分别为kernel, shell, glibc。\n通过对源码的分析，一一检索之后，发现是glibc打印了该提示。\n\n这个打印是由glibc中的strsignal函数产生的。\n退出码180跟52有什么关系\n如图所示，180表示128 + 52，表示进程是被52号信号停止的。\n","tags":["Linux","Shell","Signal","Glibc"]},{"title":"[note]高效程序员的45个习惯","url":"/2020/09/25/note-%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/","content":"高效程序员的45个习惯(Venkat Subramaniam/Andy Hunt)(人民邮电出版社)的读书笔记。\n比较重要的一些法则总结\n对事不对人，集中精力解决问题\n重结果胜于重过程\n消除误解\n解决深层次的问题\n经过充分讨论后，应该专注于执行\n行动优于抱怨\n迭代和增量式的学习\n评估新技术的优势，而不是盲目追求\n避免成为团队中最优秀的成员\n摆脱不合时宜的习惯\n设计指导实现，但是设计不宜过于详细\n保持谨慎，保证工程的可持续运行\n提早集成，频繁集成\n追求真实的估计\n重视用户的抱怨\n避免过早的优化\n对于派生类的要求 – 不要求更多，不承诺更少\n告知用户通用的错误信息并且记录日志\n\n","tags":["Note","Programmer"]},{"title":"内核程序员的自我修养","url":"/2020/06/05/%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/","content":"技术方向选择的困惑作为一个计算机科学专业出身的学生来说，有个问题一直困扰着我。那就是，我应该学习什么。学校教授给我的课程覆盖了方方面面，语言方面就涵盖C语言，Python，C++，Java，更不要提游戏设计，网站设计此类的课程。课程体系覆盖的面很广，但是缺少深度和难度。我需要找一个方向，深耕下去。构建完整知识体系的同时，也能在某个领域有深刻的见解。\n根据知识体系和兴趣，我考虑过以下几个方向：\n\n前端，技术栈围绕nodejs和angular构建\n后端，技术栈围绕Golang构建\n信息安全，准确点来说，是网络安全\n\nnodejs相关的前端大二暑假的时候，我在Coursera上接触了一门全栈课程，在后面的相当长的一段时间内，我都围绕着第一方向，构建自己的技术栈。参加过一些软件比赛，拿过一些奖，甚至实习都是做的前端开发，尽管是vue相关的。秋招过程中，学长看过我简历后，认为我更适合后端，当时没有仔细考虑学长的建议，颇为后悔。\n现在来看，围绕这个思路，这个成长过程存在以下问题\n\n我对前端的理解，始终停留在解决问题的思路上，我能很快接受新知识，并且利用这些知识解决自己的问题，但是从来没去系统学习过。我没了解过JS的闭包，对浏览器的渲染过程知之甚少，诸如此类。\n后续的成长过程中，我的兴趣更偏向于设计和美工，失去了探索前端技术本身的动力，而且对JavaScript的设计哲学和理念也不是很认同，逐步丧失了成长的基础。\n\ngolang相关的后端意识到这个问题的时候，已经是实习结束，处在大三的末尾了，我很清楚，我不会把前端作为我的方向，开始寻找其他可能。恰好这个时候，golang作为一门新语言，正在强势崛起，实习的时候因为业务需要，也有所接触。我意识到，这门语言的前景十分广阔。因此，就有了后来的ant项目，这也是我的毕业设计。我结合自己的前端优势，通过项目加深了对golang的学习，在Github上小有收获。对我来说，是个很大的鼓励。后面的很长一段时间，我也在坚持学习golang相关的东西。整体上来说，这个方向要比前端有吸引力的多，包括兴趣的吻合，实际的收益等等。\n网络安全会想到做信息安全，是因为大学时候我是打ACM出身，也了解过一些CTF的知识。刚接触的时候，给我打开了新世界，这是一种直观表现计算机水平的方式，不仅是对内行人展示，更重要的是对外行人展示。每个男孩子都有一个侠客梦想，我在相当长的一段时间内，在CTF上投入了很多精力。小有收获，但是专业性却十分欠缺。毕竟，我既不是信息安全专业出身，也找不到足够的人跟我一起参考正式的CTF比赛，属于玩票兴致，找工作几乎没指望。\n内核工程师时间节点来到毕业前，尽管因为对技术方向的错误选择，让我在nodejs上浪费了大量精力，但是却培养了我对Linux的兴趣。自己写网站，就需要自己去搭建网站，维护网站服务器，数据库服务器等等。这里面遇到的奇奇怪怪的问题，都需要自己去解决，无形中让我有了一定的运维基础。\n对Linux的兴趣，进一步培养了我对开源的兴趣，以致于后来了解到GNU运动，更是一发不可收拾。因此，在秋招拿到来自一个参与操作系统内核开发的机会时，我就毫不犹豫的选择了，尽管那时我都不知道什么是内核开发，以及内核开发要做什么。但是，这个听起来就很酷。\n经过一年时间的快速学习，作为内核工程师，我收获很多，我对编译链接，二进制，内核的调度等等都有了长足的掌握。但是，这个问题仍然困扰着我，那就是 —— 我应该如何深入。在后面的行文中，我将尝试解决以下问题：\n\n什么是内核工程师\n内核工程师的技术栈构建\n\n什么是内核工程师一般来说，很少有机会去让我们写一个内核。原因很多，首先，内核是个很复杂的东西，不仅仅在于代码规模，更在于内核对代码质量要求很高，需要开发者的素养很好。其次，计算机体系结构近些年的发展缓慢，内核没什么新的技术发展，开源世界的Linux在大多数情况下，就是最经济实用的解决方案。因此，在几乎大多数语境下，内核工程师，就是指的Linux内核工程师，这些人中，有一部分专注于驱动开发，有一部分专注于性能优化，也有一部分做虚拟化之类的东西，总之，都需要对Linux内核机制有很深的理解。\n内核的起源 – 贝尔实验室因为内核涉及的东西实在太宽泛了，作为内核工程师，从何处开始积累，这个问题困扰了我相当长的一段时间。在开始解释这个问题前，我想先讲一群人 —— 贝尔实验室。\n贝尔实验室(Bell Labs)是当时的通信业巨头AT&amp;T的一个研发机构，贝尔实验室的肯·汤普逊(Ken Thompso)、丹尼斯·里奇(Dennis Ritchie)、道格拉斯·麦克罗伊(Douglas McIlroy)于1969年开发出了unix内核。为了完成unix的开发，他们于1967年左右设计出了BCPL语言，在1970年，进一步发展出了C语言。1979年，同样供职贝尔实验室的比雅尼·斯特劳斯特鲁普(Stroustrup)，受当时流行的程序语言Simula、ALGOL 68、Ada、ML等影响，开发出了C with class。这门语言，既保持了C语言的底层支持优势，也吸取了OOP的开发效率优点，这门语言于1983年改名为C++。\n从C语言到unix内核，再到C++的出现，这三者可以说是紧密联系，相辅相成的。unix内核的发展，为后续很多内核的出现提供了蓝本，相当多的理念都被其他内核吸收，并进一步发扬光大。\n在长时间的C语言开发过程中，我深刻体会到作为底层语言的C语言，相比于纯OOP的Java语言，开发效率的底下，设计模式的单一。尽管Linux内核仍然采取C语言编写，但是在内核的开发过程中，出现了相当多的伪OOP的用法。比如一union类型中，放置不同类型的成员变量，根据type字段，将union解释成不同的类型。在我看来，这就是一种最原始的继承实现。后来，看了Inside the C++ Object Model，发现早期的C++就是用C这么实现的。C++对于内核的开发可能过于复杂(要不然也不会一直使用C开发内核)，但是C++相当多的特性，确实是一种开发效率上的长足进步。因此，C++的出现是一个很自然的事情，倒不如说，C++在保持对C相当兼容的同时，仍然支持OOP，无论如何都是一个非常惊艳的设计。\n当然，由于C++过于复杂的特性，使得开发人员困苦不堪，在2007年左右，肯·汤普逊又参与开发了一门新语言的设计，也就是后来的golang。\n内核技术栈在对编程语言的掌握上，包括:\n\nC语言  C语言相对来说，是一门比较容易的语言。但是实际使用过程中，需要对编译器的方方面面都有所了解，才能对内核的行为有充分的掌握。\nC++  对C++的学习，不单单能写出更优雅的C语言，早期的C++就是编译成C语言实现的，更重要的是，OOP已经发展成了编程语言中主流，对C++的掌握，也能对设计模式，异常处理等等一窥全貌，培养更深的兴趣。\ngolang  golang为了弥补C和C++的不足而出现，同样出自肯·汤普逊之手，处在快速崛起的时期，未来的潜力不可估量。\n\n总之，这三门语言血脉相连，有着相同的历史传承，设计上也有诸多相似之处，学习起来可以相互映照，相辅相成。既能对底层的世界一窥究竟，也能培养出对上层世界的兴趣。\n在对基础学科的掌握上，包括:\n\n汇编语言\n编译原理\n编程语言\n操作系统\n设计模式\n软件工程\n\n从汇编语言到编译原理，再到编程语言。都是为了讲清楚，底层世界是如何一步步构建起来的，以及构建过程中最重要的工具 —— 编程语言，是如何设计的。操作系统，则是在此基础上，为上层世界构建运行环境，因为操作系统通常又可以被称为”软硬件接口”。再往上，设计模式和软件工程，就是讲如何在操作系统构建的环境之上，进一步高效的构建应用。到这里，整个计算机世界，就都被串联起来了。当我写下“class A {};”的时候，我很容易就能想到，最后这串代码在内存的模型是什么样的，编译成的汇编又会是什么样的，这是一件尽在掌握中的满足感。\n技术栈展开编程语言和基础学科的学习过程，是相互促进的，不存在严格的先后关系，下面整理了我当前以及后续学习过程使用的材料。\nC++书籍：\n\nC++ Primer(第五版)\nInside the C++ Object Model\nSTL源码剖析(侯捷著)\nEffective C++\nMore Effective C++\n\n网站：\n\nBjarne Stroustrup’s C++ Style and Technique FAQ\n计算机书籍控\n\n概念和问题：\n\nC++的特性能用C来实现吗，如果可以，如何实现\nC++的历史发展和新特性(C++11)\n\n汇编语言、编译原理和编程语言书籍:\n\n汇编语言(王爽著)\nUnderstanding Programming Languages\n\n概念和问题：\n\n汇编和C语言的调用接口和规范 – AACPS(ARM中的规范)\n当前的主流编译器实现，他们之间的区别\n什么是IR\n如何评价一门编程语言，不同语言间如何比较\n\n操作系统概念和问题：\n\n当前主流内核之间的联系和发展历程\n对内核最深入的一个模块\n\n结尾这篇博客，看起来更像是我学习过程中的一个书单。当我看到贝尔实验室这段发展历史的时候，整个思路豁然开朗。无论是什么学科，对于学科历史的了解都是十分必要的，这些历史，解释了这门学科为什么发展成这样，以及解释了未来可能会是什么样。作为一个内核工程师，我沿着这群人的步伐，从底层的机器语言世界，到上层的设计模式，整个计算机世界都自然的在我眼前展开，这既让我满怀欣喜和期待，又十分忐忑畏惧。总之，这是一个很好的进展，我对于我将沿着这一道路深信不疑。\n参考\nC++维基词条\n\n","tags":["Programmer"]},{"title":"体系结构对原子操作的实现和支持","url":"/2020/06/25/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AF%B9%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%94%AF%E6%8C%81/","content":"原子操作查看以下C语言代码：\n#include &lt;stdio.h&gt;int val &#x3D; 169;int main() &#123;    val &#x3D; 275;    printf(&quot;val %d \\n&quot;, val);    return 0;&#125;\n通过GCC生成的arm64汇编如下:\n\t.arch armv8-a\t.file\t&quot;main.c&quot;\t.text\t.global\tval\t.data\t.align\t2\t.type\tval, %object\t.size\tval, 4val:\t.word\t169\t.section\t.rodata\t.align\t3.LC0:\t.string\t&quot;val %d \\n&quot;\t.text\t.align\t2\t.global\tmain\t.type\tmain, %functionmain:\tstp\tx29, x30, [sp, -16]!\tadd\tx29, sp, 0\tadrp\tx0, val\tadd\tx0, x0, :lo12:val\tmov\tw1, 275\tstr\tw1, [x0]\tadrp\tx0, val\tadd\tx0, x0, :lo12:val\tldr\tw1, [x0]\tadrp\tx0, .LC0\tadd\tx0, x0, :lo12:.LC0\tbl\tprintf\tmov\tw0, 0\tldp\tx29, x30, [sp], 16\tret\t.size\tmain, .-main\t.ident\t&quot;GCC: (Ubuntu&#x2F;Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;\t.section\t.note.GNU-stack,&quot;&quot;,@progbits\n\n在现代计算机体系结构中，对变量的赋值过程是分为三步的，以上文的val为例:\nadrp\tx0, valmov\tw1, 275str\tw1, [x0]\n\n为了加速访问，程序在运行过程中访问的变量，通常会放置在寄存器中。如果在多线程环境中，某个线程中该三步执行的间隙，该变量被用于其他线程，这就带来了脏值问题。\n为了解决这一问题，可以通过加锁解决。加锁是一种比较廉价且低效的方法，在体系结构中，提供了三个操作作为一个整体执行的原子操作。\nARMSWP指令在比较早的arm指令集中，提供SWP和SWPB指令，用于进行原子操作。用法如下：\n\nSWP{B}{cond} Rt, Rt2, [Rn]\n\n关于该指令的更多用法，参考这里\n由于该指令的效率比较低，会降低整体系统的性能，在ARMv6及之后的指令集中已经不再建议使用。\nLDREX/STREX指令在ARMv6及之后的指令集中，引入了两条指令 – LDREX/STREX 来提供原子操作。\n这两条操作，都会引起exclusive monitor(s)状态的变化，下文将举一个简单的例子。\n查看如下用法:\n\nLDREX R1, [R0]\n\n将R0地址的值加载到R1，并对相应的物理地址设置相应的标志，该标志由exclusive monitors进行管理。\n\nSTREX R2, R1, [R0]\n\n根据物理地址的状态，决定是否要进行值的写会操作。R0是将要写入的物理地址，R1中存储需要写会的值，R2则存储了这一操作的运行结果，成功返回0，失败则返回1。\n关于exclusive monitor，在arm的手册中，被描述为一个简单的状态机。LDREX被称之为Load-Exclusive指令，STREX被称之为Store-Exclusive指令。对于一个Store-Exclusive指令来说，访问中涉及到的物理内存都被标记为exclusive才能够写回成功。\n更多关于exclusive monitor的描述，可以查看参考一。\n在Load/Store-Exclusive的基础上，原子操作可以用如下代码实现(实现来自Linux):\n#define ATOMIC_OP(op, c_op, asm_op)\t\t\t\t\t\\static inline void atomic_##op(int i, atomic_t *v)\t\t\t\\&#123;\t\t\t\t\t\t\t\t\t\\\tunsigned long tmp;\t\t\t\t\t\t\\\tint result;\t\t\t\t\t\t\t\\\t\t\t\t\t\t\t\t\t\\\tprefetchw(&amp;v-&gt;counter);\t\t\t\t\t\t\\\t__asm__ __volatile__(&quot;@ atomic_&quot; #op &quot;\\n&quot;\t\t\t\\&quot;1:\tldrex\t%0, [%3]\\n&quot;\t\t\t\t\t\t\\&quot;\t&quot; #asm_op &quot;\t%0, %0, %4\\n&quot;\t\t\t\t\t\\&quot;\tstrex\t%1, %0, [%3]\\n&quot;\t\t\t\t\t\t\\&quot;\tteq\t%1, #0\\n&quot;\t\t\t\t\t\t\\&quot;\tbne\t1b&quot;\t\t\t\t\t\t\t\\\t: &quot;&#x3D;&amp;r&quot; (result), &quot;&#x3D;&amp;r&quot; (tmp), &quot;+Qo&quot; (v-&gt;counter)\t\t\\\t: &quot;r&quot; (&amp;v-&gt;counter), &quot;Ir&quot; (i)\t\t\t\t\t\\\t: &quot;cc&quot;);\t\t\t\t\t\t\t\\&#125;ATOMIC_OP(atomic_add)\n\n更多关于原子操作，可以查看Linux arch源码里的atomic.h\nX86X86的指令支持”lock”前缀，对于支持该前缀的cpu指令，使用该前缀后，能够保证是原子执行的。\n参考\nDHT0008A_arm_synchronization_primitives.pdf\nLDREX/STREX(arm)\nAtomic operations in ARM(StackOverflow)\n\n","tags":["Computer Architecture","X86","ARM"]},{"title":"嵌入式设备中的Linux引导方式","url":"/2019/11/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E4%B8%AD%E7%9A%84Linux%E5%BC%95%E5%AF%BC%E6%96%B9%E5%BC%8F/","content":"概述主要是总结Linux的引导过程，包括:\n\n从开机到控制权交接给内核\n内核初始化过程\n用户空间初始化过程\n\n本文参考的Linux代码版本是2.6.x，是比较老的版本，如果与最新的代码特性有出入，以最新的为主。\n嵌入式设备的关键属性嵌入式设备和非嵌入式设备并没有明确的界限，嵌入式设备通常具有以下属性：\n\n包含一个处理引擎，比如通用微处理器\n一般是针对某种具体的应用或目的设计的\n用户界面通常不是考量的关键因素，甚至会为了安全性而牺牲一部分可用性\n资源通常受限，比如没有硬盘，供电受限等等\n应用程序通常是内置的，出厂时，软硬件均已经集成完善。\n\n\n\n从开机到控制权交接给内核对于这一过程的概述，嵌入式设备和一般的桌面PC设备稍有差别，也可以说是ARM世界和x86世界的差别。\n在一般的桌面PC系统中，通电之后，Bios立刻接管了设备，在完成硬件自检等工作后，跳转，将控制权交给Bootloader，如果硬盘里不只安装了一个系统，在Bootloader这一步可以决定启动哪一个操作系统。在这个语境中，Bios被称为“first-stage boot loader”，bootloader被称为“second-stage boot loader”。主流的Bootloader包括bootmgr, grub等等。\n在嵌入式设备中，通常不会有多个系统的情况，因此，不需要将整个引导过程拆成两步进行。所以，嵌入式设备中，很少使用bios的概念，而是直接将两个步骤统称为 bootloader，本文以下内容涉及到的bootloader，除非特别说明，都是指嵌入式开发中的概念。\n在嵌入式设备中，bootloader的关键职能，包括：\n\n初始化关键的硬件，比如SDRAM控制器，I/O控制器和图形控制器\n为外设控制器分配必要的系统资源，比如内存和中断电路\n提供一个定位和加载操作系统镜像的机制\n加载操作系统，并将控制权移交给它，同时传递必要的启动信息。内容可能包括内存总容量、时钟频率、串行端口频率（波特率）等等\n\n嵌入式开发过程中，使用最为广泛的bootloader便是U-Boot。本文不会过多的涉及U-Boot的内容，以避免行文过于臃肿，U-Boot的用法可以参考补充内容。\n\n\n内核空间初始化过程如果bootloader引导顺利的话，控制权接着就转交给了linux内核。\nLinux内核的引导过程比较复杂，本文从源码角度简单介绍下其中比较重要的几个环节。\n\n\n内核入口 head.Shead.S位于../arch//kernel/head.S，从目录也可以看出，该文件是用来处理架构相关的初始化工作，主要有以下的作用：\n\n检查处理器和架构的有效性\n创建初始的页表（page table)表项\n启用处理器的内存管理单元（MMU）\n进行错误检测并报告\n跳转到内核主体的起始位置，即main.c中的函数start_kernel()\n\n\n\n内核开始 main.c该文件位于../init/main.c中，如前文所述，head.S在执行结束后，将开始执行main.c中的start_kernel()。main.c完成大部分内核启动工作，从初始化第一个内核线程开始，直至挂在根文件系统并执行最初的用户空间Linux应用程序。\n主要工作及过程如下：\n\n架构设置\n 通过调用setup_arch(),完成对某种架构通用的初始化工作，该参数接受一个指向内核命令行的指针 –&gt; setup_arch(&amp;command_line)\n\n内核命令行的处理\n 内核命令行是引导程序启动时，向内核传递的参数，相比与编译时指定的参数，cmdline要灵活得多。一个典型的cmdline通常如下:\n\nconsole=ttys0,115200 root=/dev/nfs\n\n cmdline拥有的参数可以多达上百个，内核中使用__setup宏将cmdline与相关的模块关联起来。其一般用法如下所示：\n\n__setup(“console=”, console_setup);\n\n 含义为，当cmdline中遇到console=字符串时，就调用__setup宏的第二个参数指定的函数。详细的过程涉及到ELF文件的生成和链接器的使用，不在本文的讨论范围。内核会遍历cmdline中的参数，并调用相应的处理函数。\n\n子系统的初始化\n 子系统的初始化有两种方式，一种是显式初始化，比如调用init_timers()函数，console_init()函数，另外一种是借助类似__setup宏这种技巧实现的初始化，承担这种宏有一个系列*__initcall，具体过程本文不涉及。\n\ninit线程\n 执行到这里，内核生成了第一个内核线程 – init线程。init线程是Linux所有用户空间进程的父进程。需要说明的是，对于linux来说，并没有严格区分线程和进程，他们由同一种结构表示，区别在于资源的调度。\n\n最后的引导步骤\n 在完成初始化工作之后，内核开始执行最后的引导步骤，包括：\n\n释放初始化函数和数据占用的内存\n打开系统控制台设备\n启动第一个用户空间进程\n….\n\n if (execute_command) &#123;    run_init_process(execute_command);    printk(KERN_WARNING &quot;Failed to execute %s. Attempting&quot;            &quot;defaults...\\n&quot;, execute_command);&#125;run_init_process(&quot;&#x2F;sbin&#x2F;init&quot;);run_init_process(&quot;&#x2F;etc&#x2F;init&quot;);run_init_process(&quot;&#x2F;bin&#x2F;init&quot;);run_init_process(&quot;&#x2F;bin&#x2F;sh&quot;);panic(&quot;No init found, Try passing init&#x3D; option to kernel&quot;);\n 上述代码来自main.c中的init_post函数最后一段，如果该函数执行到最后，将会产生一个”No init found”的错误，这也是嵌入式开始过程中见到比较多的一个错误。run_init_process执行成功后，并不会返回，而是通过execve()系统调用生成一个新进程覆盖旧进程，因此，init过程是第一个执行成功的run_init_process函数。\n\n\n\n\n用户空间初始化根文件系统，简单的说，就是内核挂载最早的文件系统。如上文所说，内核引导的最后，会试图通过run_init_process执行类似/sbin/init的二进制程序。根文件系统，在进行到最后的引导步骤前，就已经初始化并挂在完成。\n根文件的生成，挂在过程，会在另外一篇blog中详细介绍。在run_init_process执行成功后，第一个用户态程序便开始执行了。\n补充\n\n1. dtb,dts,dtc介绍及常用用法dts,即device tree source。是arm嵌入式中，用于描述硬件的方式。dts通过dtc工具，生成供内核使用的dtb文件。\n\n\n2. U-Boot的一般用法\n加载内容镜像到固定内存地址\ntftp 600000 uImage\n加载dtb到固定内存位置\ntftp c00000 dtb\n根据之前的dtb开始引导系统\nbootm 600000 - c00000\n\n\n\n从磁盘引导\ndiskboot Ox400000 0:0\n此处中的0：0指第一个IDE设备的第一个分区\n\n从内存的某个位置开始引导\nbootm Ox400000\n\n\n\n\n需要区分的概念\nBIOS-MBR 与 GPT-UEFI\nGRUB, GRUB2\nROM 与 EEPROM\nU-boot\ndtb, dtc, dts\n\n\n\n参考\n《嵌入式LINUX基础教程（第2版）》 第1章至第7章\nThe BIOS/MBR Boot Process\nbooting\n\n","tags":["Linux","Uboot","Bootloader","Bios","Arm"]},{"title":"[note]理解编程语言","url":"/2020/02/14/note-%E7%90%86%E8%A7%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","content":"Understanding Programming Languages (M.Ben-Ari) 的读书笔记。\n\n\n\n编程语言定义，组成及编程环境\n\n编程语言定义对程序员来说，编程语言只是编程的工具，很多程序员沉迷于比较不同的编程语言，但是缺乏分析不同语言特点的能力。\n编程语言知识的匮乏，导致以下问题：\n\n尽管计算机硬件和现代软件系统的爆炸发展，大多数人仍然使用1970年甚至更早之前发展出的语言。编程语言的发展落后，使得程序员不得不采用更多的工具和方法进行弥补。\n在选择开发语言时，没有充分考虑安全性和效率，导致开发出的项目难以维护，开发者常常通过汇编而不是算法和编程本身来解决效率问题。\n\n编程语言的存在，是为了弥补硬件和真实世界之间的不同抽象差距。高抽象的语言易于理解和使用，低抽象的语言则更为灵活和高效。设计和选择一门语言，就是选择一种合适的抽象。\n从数学上来说，一个程序是详细说明一个运算过程的一段符号序列。一门编程语言是描述这个序列如何构成以及运算过程含义的规则集合。\n编程语言分类在wiki百科中，对编程语言分类方式的描述是：\n\n编程范式、编程范式或程序设计法(Programming paradigm)，是一类典型的编程风格，是指从事软件工程的一类典型的风格。如函数式编程、过程式编程、面向对象编程、指令式编程等等为不同的编程范型。\n编程范型提供了（同时决定了）程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。\n正如软件工程中不同的群体会提倡不同的“方法学”一样，不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的（如Smalltalk和Java支持面向对象编程，而Haskell和Scheme则支持函数式编程），同时还有另一些语言支持多种范型（如Ruby、Common Lisp、Python和Oz）。\n很多编程范型已经被熟知他们禁止使用哪些技术，同时允许使用哪些。例如，纯粹的函数式编程不允许有副作用；结构化编程不允许使用goto。可能是因为这个原因，新的范型常常被那些习惯于较早的风格的人认为是教条主义或过分严格。然而，这样避免某些技术反而更加证明了关于程序正确性——或仅仅是理解它的行为——的法则，而不用限制程序语言的一般性。\n编程范型和编程语言之间的关系可能十分复杂，由于一个编程语言可以支持多种范型。例如，C++设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用C++写出一个完全过程化的程序，另一个人也可以用C++写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。\n\n以下是常见的分类：\n指令式语言和声明式语言指令式语言(Imperative programming)，即详细的描述整个过程，一步步的告诉计算机如何完成计算过程。考虑一个简单的数学问题 —— 从一组数中寻找最大数，对于指令式语言来说，过程通常如下：\n\n创建一个用于保存结果的变量\n遍历数组，一一比较\n将最终的结果返回\n\n声明式语言(Declarative programming)，即告诉计算机结果应该满足的条件，由编译器来决定如何获得结果。\n相同的问题，对声明式语言来说，最大的数就是结果限制，编译器会自动推导出过程。\n声明式语言,主要用于处理大量数据或者那些解决过程无法被详细描述的问题，包括：\n\nlanguage processing(语言处理)\npattern matching(模式匹配)\nprocess optimization(模型优化)\n\n指令式语言和声明式语言是一个相对的概念，如上文所说，编程语言是为了弥补硬件和真实世界之间的抽象差距。对于最底层的CPU指令来说，其核心就是用“变量定义 + 顺序执行 + 分支判断 + 循环”来表达逻辑过程。上层的应用，则是通过层层封装，来表现现实世界中的过程。越接近底层的表达，就越“指令式”;越接近现实世界的表达，就越“声明式”。\n一般来说，C/C++，Java，JavaScript，Python等等被认为是指令式语言。SQL，HTML/CSS等等被认为是声明式语言。指令式语言通常需要更多的表达，声明式语言通常在效率上有所损失。\n编译型语言和解释型语言编译型和解释型语言的差别在于，生成目标CPU指令的时机不同。编译型是语言是源代码通过编译器，直接生成特定CPU体系的可执行文件。解释型语言通过源代码生成一种平台无关的中间代码，在运行过程中再将中间代码解释成目标平台的CPU指令。\n一般认为C/C++等等是编译型语言，JavaScript、Python等等是解释型语言。相对来说，编译型语言效率更高，解释型语言更为灵活。但是，当前编程语言的发展，编译型语言和解释型语言的界限并不是特别清晰，考虑以下几个情况：\n\nJava代码首先会被编译成虚拟机指令，然后，由虚拟机执行的时候，翻译成目标架构CPU指令。在一些教科书上，Java被成为半编译型或者混合型语言。\n\nPython既可以直接解释源代码执行，也可以编译成虚拟机指令后，运行。\n\nC#的源代码会首先被编译成一种中间文件，然后，借助.Net Framework虚拟机，通过中间代码，直接生成目标CPU架构的可执行文件。接着，直接执行该可执行文件。\n\n通过V8引擎，JavaScript源码可以直接生成目标CPU架构指令。这种应用在解释器上的技术，被称为JIT(即时编译, Just-In-Time)。对于解释型语言来说，通过JIT，再将生成的目标文件缓存起来，与编译型语言直接生成可执行文件，其实是没有太大区别的。\n\n\n如上文所说，编程语言本质是为了弥补硬件和真实世界之间的抽象差距。所谓编译型/解释型，只是最终生成目标CPU指令的时机不同。两者之间的界限是非常模糊的，在一些情况下，甚至是可以相互转化的。\n面向数据编程面向数据编程，即围绕着一种数据结构以及与数据结构相关的操作进行编程。这种编程范式在编程语言发展早期非常流行，这种编程语言主要用于科学计算和研究中，从数学的角度，而不是从工程的角度来实现语言。\n支持该种设计的语言包括：\n\nLisp: Lisp的基本数据结构是linked list，当前，Lisp主要活跃在人工智能领域。\nAPL : APL的基本数据结构是vectors和matrics, APL是从数学形式体系中发展出来的。\nSnobol/Icon :Snobol和Icon的基本数据结构是string，主要用于文本处理。\nSETL: SETL的基本数据结构是set，用于数学计算。\n\n这种类型的语言，当前已经不再那么流行，主要由于以下两个原因：\n\n面向对象语言，拥有类似的能力。\n函数式编程和逻辑式编程概念的出现。\n\n\n\n面向对象编程(OOP)面向对象编程(Object-oriented programming, OOP)，即将对象作为基本单元的编程方式。对象，是对真实世界中物体概念的抽象，对象包括数据以及对相应数据的操作。\n最早出现的OOP语言是Simula，于20世纪60年代由K.Nygaard和O.-J.Dahl开发，用于系统仿真。\n早期OOP中发展出的最重要的概念为 – 动态(dynamic, run-time)内存分配，动态运行调度，动态类型检查。区别于静态(static, compiler-time)，动态会带来额外的时间和内存花销。\nC++既支持静态内存分配和静态类型检查的，也支持OOP的动态内存分配和动态类型检查。这表明，动态和静态的设计并不冲突，动态可以在需要的时候使用。就OOP来说，Java要比C++的设计更为“纯粹”。\n编程语言标准化编程语言的标准化，对编程语言的发展至关重要。但是，标准化常常是滞后于编程语言发展的。以C语言为例，gcc实现的很多特性，并不是标准C语言支持的，这些特性有些被广泛接受，成为后续标准的一部分，有些没有被接受。如果这些非标准的特性被使用，一定要特别谨慎，因为这会导致程序的兼容性变差。\n编程语言存在的理论基础(可计算性)在20世界30年代，早于电子计算机发明之前，逻辑学家已经开始研究计算的抽象概念。Alan Turing和Alonzo Church分别提出一种经典，简单的计算模型，分别叫做图灵机和λ演算。随后，Church-Turing 猜想被提出：\n\n任何在算法上可计算的问题同样可由图灵机计算。\n\n尽管该猜想未能被证明，但是，到目前为止，几乎是被全面接受的。\n图灵机的基本思想使用机器来模拟人们用纸笔来进行数学运算的过程，图灵机将这种过程分成四步：\n\n一条无限长的纸带TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号□表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, …，纸带的右端可以无限伸展。\n一个读写头HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。\n一套控制规则TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：\n写入（替换）或擦除当前符号；\n移动 HEAD， ‘L’向左， ‘R’向右或者’N’不移动；\n保持当前状态或者转到另一状态\n\n\n一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。参见停机问题。\n\n图灵机的模型是如此简单，任何编程语言都可以实现对图形机的模拟。因此，如果图灵机可以解决一个问题，那么编程语言同样可以。\n编程语言的构成元素\n\n句法(Syntax)句法，是定义编程语言中有效符号序列的规则集合。\n句法，通过形式记号(formal notation)来描述。句法中最广泛使用的形式记号是扩充巴科斯范式(Extended Backus-Naur Form，EBNF)。\n句法相关的常见错误包括：\n\n标识符的长度限制\n大小写是否敏感\n注释的不同写法\n写法接近但含义完全不同的符号(= vs ==)\n分割符\n\n\n\n语义(Semantics)语义，是编程语言中表达式的含义，即描述程序如何在不同状态之间进行转换。\n形式化编程语言语义(a formalization of the semantics of programming languages)的好处在于，程序的正确性很容易得到证明。如果程序的输入数据满足要求，那么相应的输出也将符合预期。\n数据(Data)编程语言中，都会有对数据的抽象。即使是最底层的汇编语言，也是基于对寄存器、内存单元之类的物理实体的操作。因此，编程语言可以有如下定义：\ntype(类型): 值，以及对这些值的操作的集合value(值): 一个未定义的基本概念Literal: 程序中文字声明的特定值Representation: 值在计算机中的二进制表示Variable: 存储值的内存单元名称Constant: 不变的值Object: variable or Constant\n对于一个Variable来说，一定是某个特定的类型。因为，只有知道了类型，编译器才能分配相应的内存。\n赋值语句编程语言的赋值过程分为3步：\n\n计算右值\n计算左值地址\n将右值存储于左值地址\n\n\n\n类型检查类型检查用于检查赋值过程中右值结果与左值类型是否兼容。\n赋值包括函数调用过程中，将实参赋给形参，可能的结果有3种：\n\n类型一致\n隐式转换\n无法转换，报错\n\n类型转换是可靠性和便捷性之间的一种权衡。\n控制语句控制结构有2种：\n\n选择语句\n循环语句\n\n\n\n子程序和模块对于大型的工程来说，不同的程序语言，提供了不同的组织方式。比如，C语言的.c，.h文件，Java的包管理器等等。\n编程环境使用编程语言的过程中，需要一系列的工具，包括：\n\n编辑器\n编译器/解释器\n链接器\n装载器\n库管理工具\n调试器\n分析器\n测试工具\n配置工具\n\n\n\n编程语言的基本概念\n\n基本数据类型\nInteger types\nEnumeration types\nCharacter type(可以借助Enumeration types实现)\nBoolean type\nSubtypes(已有类型+使用限制)\nDerived types\nExpressions(一般借助逆波兰表达式[RPN]实现)\nAssignment statements\n\n\n\n复杂数据类型\nRecords\n  Records是由一系列其他类型组成的统合，比如C语言中的struct，Ada中的components。Records的定义表明了其内存布局，组成Records的每一个部分，都对应的名称和类型，编译器可以很容易的计算出每一部分的offset，从而找到其在内存中的位置。\nArrays\n  Arrays与Records的不同在于，Arrays是由同一类型组成的。\nReference semantics(引用)\n  C/C++的设计中，pointer的使用常常导致严重的bug。Ada通过类型检查和访问级别(access levels)来规范pointer的使用，Java/Eiffel/Smalltalk则使用引用来解决这一问题。对于Java来说，非基本类型的声明，不会导致相应类型内存被分配，只是获得了一个隐式的指针，内存的分配需要通过new来获得。引用可以看做更加安全的指针用法，内存分配，寻址，越界检查等等的操作都是由编译器自动完成的，也就减少了出问题的概率。\nString type\n  字符串，本质上就是char类型的数组。但是，通常，编译器会提供一些语法糖，来增强字符串的用法。\nMulti-dimensional arrays\n  多维数组有两种声明方式：一种是直接声明，比如C语言中的a[2][2];一种是声明类型是数组的数组。\n\n控制结构\nswitch-/case-statements\n\nif-statements\n  if有两种实现：(1) short-circuit evaluation: C语言采用的就是这种实现，即逻辑计算过程中，一步步进行，如果结果确定，就不进行后续计算。(2) full-evaluation: 将逻辑表达式作为一个整体，计算出结果后跳转。 短路的实现，可以执行更少的指令，但是需要更多的jump，也就需要更多的内存去存储多余的指令。两者之间的效率对比取决于逻辑表达式的复杂程度。\nloop statements\n\nfor-statements\n\nsentinels(一种循环优化写法)\n  一个改善循环写法的技巧，比如在长度为N的数组A中寻找dst，将数组A扩展至N+1, 最后一个元素存储为dst，从头遍历数组，判断返回的下表即可知道数组是否包含dst。这种写法被称为“哨兵”，好处在于，只需要判断值是否相等，不需要担心下标越界，因为总会有满足的下标，从而减少了所需要的判断，提升了效率。\ngo-to statements\n  关于goto，是否应该被使用在编程语言中，仍然存在严重争论。反对者中包括Dijkstra，1968年Dijkstra写了一篇著名的文章 - “goto Considered Harmful\"，阐明他反对goto的原因。\n\n子程序结构\n子程序定义\n  子程序是程序中独立的编译/执行单位，使用子程序的好处是显而易见的： (1)代码复用，节省空间，提高开发效率。(2)代码的可读性和维护性都会得到提升。子程序通常包括：(1)接口，表明子程序的调用方式。(2)子程序使用到的本地参数。(3)子程序实现。C语言中最典型的子程序结构是function。\n传参\n  传参过程中有两种定义需要区分：(1) 形参(formal parameter)：形参是函数声明中的参数值。(2)实参(actual parameter):函数调用发生时，实际传给子程序的参数值。传参的方式有两种，一种是值传递，一种是地址传递。地址传递可以看做特殊的值传递，传递的值是地址，地址传递过程中经常会有踩内存的问题，需要对程序的内存管理有一定了解，才能最大程度上缓解该问题。一些编程语言的实现中，将参数和具体的名称关联，允许默认参数，简化了传参过程。\nBlock structure\n  这个概念，我没找到很好的翻译。所谓Block structure，就是子程序的主体部分，即除了声明之外的部分。编程语言对Block structure的支持，主要有两个区别：(1) 是否被命名。(2)是否支持嵌套使用。C语言对应的支持为：(1)未命名(2)不嵌套。未命名的Block structure是为了约束变量的使用范围;嵌套则是为了在子程序内部进一步复用重复的逻辑。这也引出一个很重要的问题，即参数是否能被访问。有3个概念对此进行描述：(1)访问范围 - scope (2) 可见性 - visibility (3) lifetime - 生命周期。一般来说，在访问范围内，变量都是可见的。但是存在一种变量被隐藏的情况，以C语言为例，如果函数体内部有跟全局变量同名的本地变量，那么对于该全局变量来说，就是可以访问，但是不可见。相比与写成子程序，Block structure的优势在于可以访问内部的变量。问题在于，过多的嵌套，会造成代码难以维护。Javascript对于嵌套函数的使用，就是一个很好的例子。在嵌套的调用过程中，对于如何获取外部的参数，存在两种方式：(1)Dynamic chain：每部分都保存指向上级内存的指针，层层回溯，直到找到需要的参数值。(2)Static chain: 嵌套调用过程中，给每个调用部分设定一个level，仅寻找level低于当前调用部分的上级，这是编译器的一种优化策略，缩短寻找的过程，具体内容可以查询参考9。\n\n编程语言的高级概念\n\n指针指针，即存储的内容是一个内存地址。无论指针指向的类型是什么，指针占用的内存大小都是一样的，都为一个字长。指针的类型，决定了编译器对地址开始的内存空间的解释，以及偏移的计算。\n\n指针的操作包括：取地址，解引用，赋值，地址自增、自减。根据这些概念，又出现了二维指针，数组等概念。大体上，指针和类型，结合内存管理，实现了对内存的解释。\n\n在内存的管理上，内存类型可以分为Code/Constants/Stack/Static Data/Heap 。其中Heap的使用比较灵活，类似C这种偏底层的语言，完全由开发者管理，类似于Java这种上层语言，则发展出了垃圾回收机制。\n\n\n\n数的表示(Real Numbers)\n数的表示方法\n  对于小数0.2，有两种表达方式，一种是直接表示对应的十进制数，即对于小数的每一位，直接分配4个bit表示，这种方法被称为 binary-coded decimal(BCD)。一种是分权二进制表示，即第一位表示1/2，第二位1/4，以此类推，这种方法是存在精度损失的。\n\n  由于BCD使用四位bit去表示十种情况，对内存的浪费事比较多的。同时BCD的表示方法，也不利于运算。因此，实际使用中，二进制表示法更为广泛，只有少数语言支持了BCD，比如Cobol。\n定点数(fixed-point numbers)\n  定点数表示，即使用固定的位数表示小数点前面的部分，使用固定的位数表示小数点后面的部分。\n\n  定点数表示法的优势在于，足够准确，即绝对错误比较小。劣势在于，不够精确，相对错误较大。\n浮点数(float-point numbers)\n  浮点数表示法，发展自科学计数法。将数通过科学技术法表示成固定形式，再分别存储数的符号，底数和指数部分即可。\n\n  浮点数表示法的优势在于相对错误较小，因为指数部分是单独存储的。缺点在于绝对错误较大，相对错误会被指数部分进行放大。\n硬件和软件浮点\n  一般来说，浮点计算是有专门的硬件支持的。对于没有硬件支持的计算机来说，可以通过触发异常，使用软件模拟浮点运算。\n浮点运算的三类错误\n  浮点数运算中，存在三类比较常见的错误：(1)微增(Negligible addition):一个很大的数加上一个很小的数，由于浮点数的表示，很小的数会被忽略不计。(2)错误方法(Error magnification):由于浮点数的表示方式，很小的相对错误被指数方法后，绝对错误很大。(3)失去含义(Loss of significance):计算机中的比较，是通过相减，然后将结果与0相比较。由于浮点数的表示方式，或者是编译器的优化，都会导致一定的误差。从而导致最终的结果不符合预期。一般来说，会将结果在一个小范围内进行比较。\n\n多态(Polymorphism)\n类型转换\n  类型转换，即从一个类型，转换到另外一个类型。有两种情况：(1)将一种类型的值，有效的转换为另外一种。(2)将值转换为未被解释的比特字符串。(即存储内容不变，解释方式变化。)\n重载(Overloading)\n  重载，即在同一个作用范围里，使用同一个名字来表示不同的实体。\nGenerics(泛型)\n  泛型，是一种在编译时，由编译器来决定类型的类型。泛型的出现，是为了复用那些类型无关的代码，比如最常见的排序算法。\nVariant records(可变类型)\n  可变类型，是指同一种可以被解释成不同的内存布局。C语言中比较常见的用法是，一个结构体中，存在一个字段表明类型，以及一些共同的字段，以及一个联合体。依据类型的不同，联合体的解释也不同。\nDynamic dispatching(动态分发)\n  在运行时，根据类型，运行对应的路径。动态分发，一般用在面向对象的设计中。\n\n\n\n异常(Exception)\n异常的定义\n  异常，即程序遇到错误时，需要做的处理。简单的可以是打印一些现场信息，复杂的则需要做一些处理，帮助恢复程序的运行，如果是不可恢复的问题，则直接退出。\n异常的代价\n  引入异常机制的代价主要来自于两个方面：(1)异常检测和处理本身需要额外的实现和运算。(2)异常处理代码本身也可能有bug，从而继续引发问题。\n好的异常处理机制\n  从异常的代价很容易就看到，一个好的异常处理机制应该满足:(1)在没有异常发生时，异常机制引入的代价几乎可以忽略不计。(2)异常机制应该是安全且易于使用的。\n异常机制与if的区别\n  if表明的是一种可能性的判断，是预期内的事情。异常是预期之外发生的事情，一般表明程序运行出了问题。\n异常机制的实现\n  异常机制，一般通过一张异常向量表实现。由于异常极少数情况下才会发生，异常向量表的代价几乎可以忽略不计。\n\n\n\n并发(Concurrency)\n并发需要处理的问题\n\n同步(Synchronization)\n通信(Communication)\n\n\nCSP(Communicating Sequential Processes)(单独开坑写写这个)\n\n\n编写大型系统程序分解\n分开编译\n模块化编程\n依赖管理\n\n面向对象编程\n面向对象编程的三个特征\n\n封装和抽象(Encapsulation and data abstraction)\n继承(Inheritance)\n多态(Dynamic polymorphism)\n\n\n关于面向对象的更多内容\n\n虚拟类(Abstract classes)\n泛型(Generics)\n多继承(Multiple inheritance)\n\n\n\n\n\n非指令性编程语言(Non-imperative Programming Languages)\n面向函数编程(Functional Programming)\n  面向函数编程，更符合数学思维的表达习惯。对函数式编程来说，不需要直接管理内存，也不存在一般语言中组件间相互作用带来的副作用。代表性的语言包括：ML(Meta Language)\n面向逻辑编程(Logic Programming)\n  面向逻辑编程，即把计算过程，分解成一个个逻辑表达式。整个编程风格是高度抽象，声明式的。代表性的编程语言包括：Prolog\n\n\n\n参考\n声明式编程和命令式编程有什么区别？\n解释型语言和编译型语言的区别\n程序的编译与解释有什么区别？\nJavaScript、Node.js与V8的关系\n编程范型\n邱奇－图灵论题\n图灵机\n扩充巴科斯范式\nImplementing Subprograms\n\n","tags":["Note","Program Language"]},{"title":"Linux Kernel Module加载卸除过程分析","url":"/2021/04/06/Linux-Kernel-Module%E5%8A%A0%E8%BD%BD%E5%8D%B8%E9%99%A4%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","content":"文章参考的代码信息\n内核: Linux v5.12-rc6\n架构: X86\n\nKernel Module的加载过程读取kernel module到内存(kernel/module.c)内核中用于module load的系统调用有两个：finit_module和init_module。区别在于，finit_module接受的是一个fd，init_module直接从内存中复制。这两个调用是内核模块加载的入口，最终都会调用到load_module。加载过程中使用的管理结构为struct load_info，kernel module在内核内存中的地址，是通过__vmalloc申请出来的，被记录在info-&gt;hdr。\n检查签名是否存在\nmodule_sig_check\n 读取info-&gt;hdr末尾的一部分，并进行校验。检验结束后，更新info-&gt;len。\n\nelf_validity_check\n 校验ELF相关的内容\n\n\n处理并加载section(setup_load_info)\n读取modinfo section\n .modinfo这个section中放入module相关的一些描述信息。通过readelf -p .modinfo xxx.ko可以读出相应的信息，包括version，description，author等信息。\n\n遍历各个section，获取符号表信息(strtb和symtb)，这一过程中，需要根据info-&gt;hdr和section中的offset，计算出真正的内存地址\n\n读取.gnu.linkonce.this_module section\n\n尝试读取__versions section，并更新info-&gt;index.vers\n\n\n查看是否是被禁止加载的模块(blacklisted)读取kernel中的module blacklist，这一过程中判断的依据是info-&gt;name，如果info-&gt;name在blacklist中，则不加载该模块。\n更新各个section的地址二进制中的section记录的是内存offset，以info-&gt;hdr为基准，进行重定位。\n清除vers和info相关section中的SHF_ALLOC标记，后续过程中将不会分配内存。\n检查module中的version信息是否存在\nfind_symbol\n 从已经加载的kernel和module符号中，寻找name为module_layout的符号，并获取到相应的信息。\n\n进行crc和version校验\n\n\n根据读取到的section信息，对内存进行分配\ncheck_modinfo\n 对vermagic进行校验，如果不是由内核本身维护的module，设置污染标记(内核会打印’loading out-of-tree module taints kernel’)\n 检查module的编译信息\n 检查是否有live-patch(check_modinfo_livepatch)\n 设置license(set_license)\n\nmodule_frob_arch_sections\n这个函数设置了weak属性，允许arch层重定义该函数，X86中未找到相关定义。\n\nmodule_enforce_rwx_sections\n 检查各个section的flag\n\n清除per-cpu sections标记中的SHF_ALLOC\n\n将.data..ro_after_init标记为SHF_RO_AFTER_INIT(read only after init)\n\n将__jump_table标记为SHF_RO_AFTER_INIT\n\n遍历各个section，将section划分成两部分，分别是core part和init part。init part将在初始化完成后丢弃，从而节省内存。对于每个part，又细分为四类，分别是text，ro，ro_after_init，other，细分是为了后面设置内存页的权限。\n\n设置core和init的符号表(layout_symtab)\n\nmove_module\n 根据7和8获取到的core和init的信息，将需要的信息从二进制中复制到core和init中，此时获得的地址，便是最终的运行地址。这一步执行结束后，mod变量被正确赋值。\n\n\n初步加载kernel module内核中管理module的结构为struct module\n\n初始化一个struct module，并更新状态为MODULE_STATE_UNFORMED\n\n查看kernel中是否已经加载相关module\n\n更新module_addr_min和module_addr_max\n\n将struct module插入到kernel的list中，此时，该module开始被kernel识别并管理\n\n校验签名\n\n\nmodule运行现场的初始化\n分配内存给percpu section\n\n初始化mod的依赖管理结构(source_list和target_list)\n\n引用计数置为1\n\n初始化mod-&gt;param_lock\n\n\nfind_module_sections\n获取存有元数据的section，包括导出的符号表，crc校验参数等等\n\n校验license和version(check_module_license_and_versions)\n\n设置Module的描述信息(从.modinfo section中读取的内容)\n\n\nsimplify_symbols这一步比较重要，进行符号表偏移的计算。对于SHN_UNDEF的符号，将在内核中进行查找，查找成功后，更新相应的依赖关系。对于weak属性的符号，会做进一步的检查和处理。对于除SHN_COMMON，SHN_ABS，SHN_LIVEPATCH，SHN_UNDEF之外的一般符号，依据符号的偏移以及所属section的基址，计算出符号的内存地址。\nsection重定位\napply_relocations\n 进行符号的重定位，有一类特殊的section，记录了对应section的relocation信息。relocation的计算分为三步：\n\n计算二进制中重定位部分的内存位置(src)\n根据type，计算内存中重定位部分的内存地址(dst)\n校验dst部分是否全为0，如果是，执行write(dst, src, size)\n\n\npost_relocation\n\n对exception table进行排序\n执行符号表的拷贝工作(此时的符号表位置已经计算出来)return module_finalize(info-&gt;hdr, info-&gt;sechdrs, mod);\narch相关的结束动作()\n\n\n刷新cache(flush_module_icache)，获取module的运行参数\n\n\n开始运行module前的准备\n查看是否有重复的符号\n\n对init和core部分的四个类别section进行内存权限设置\n\n设置module状态为MODULE_STATE_COMING\n\n对内核的通知链发出一个通知，此后状态为MODULE_STATE_GOING\n\n解析参数\n\n设置sys相关的文件(mod_sysfs_setup)\n\n\n开始运行module\n如果注册了init，执行init函数\n对内核的通知链发出一个通知，此后状态为MODULE_STATE_LIVE\nmod计数减一\n释放init区域\n\nKernel Module的卸载过程\n检查是否有权限进行卸载\n\n从用户参数中获取所要卸载的模块name\n\n根据name寻找相应的module结构(find_module)\n\n检查是否有其他模块依赖待卸载模块\n\n执行module的exit函数\n\n释放module占据的资源，更新内核的管理数据\n\n\n相关Q&amp;A\ndata段和bss段的区别\n bss段由于不存在初始化值，在二进制中不需要分配位置存储，因此bss变量不会造成二进制变大。但是，在进行二进制加载时，会分配相应的内存。在符号表中，尽管bss段在二进制本身中不占据位置，但是在运行内存中占据了位置，因此偏移计算时，是将bss段作为有size进行处理的(因为符号表是描述运行内存布局的)。\n\n是否可以将某些section单独管理\n 原理上是可行的，我尝试过将bss和data单独分离出来。需要考虑的几个点:\n\n修改符号表的偏移，偏移是重定向的依据。\n如果原有地址存在数据，重定向对0值的校验会失败。\n\n\nkernel module为何要export符号，才能被其他模块使用\n export出来的符号会单独放在一个section中，module本身的符号表对内核其他部分是不可见的。但是，module跟内核其他部分是在一个地址空间里的，缺少的只是内存布局信息(也就是符号表)。\n\n\n参考\nelf header\n深入Linux设备驱动内核机制(陈学松著)第一章\n\n","tags":["Linux","Kernel Module"]},{"title":"国内宠物托运指南","url":"/2021/04/06/%E5%9B%BD%E5%86%85%E5%AE%A0%E7%89%A9%E6%89%98%E8%BF%90%E6%8C%87%E5%8D%97/","content":"自从有了花花，大到出行，小到搬家，都像是带着孩子的寡妇，逢人总要问一句，“您这能托运(住)猫吗”。\n这篇记录下我从杭州带着花花去北方的过程，总结下如何带着宠物旅行。\n\n自驾带着宠物这是最安全，也是最折腾的办法。唯一需要考虑的，是长达两三天的路途，宠物是否能适应用厕，饮食。当然，代价就是极其高昂的花费，包括但不限于车辆使用费，油费，住宿费等等。\n航空托运托运一只宠物，需要满足以下要求:\n\n宠物有卫生部门开具的检疫合格证明\n航班存在有氧舱，且愿意接收宠物(一般大的客机里会有2-3个名额)\n\n卫生部门开具检疫合格证明卫生部门开具检疫合格证明需要满足以下条件:\n\n宠物拥有免疫证\n宠物按期接种狂犬疫苗\n\n免疫证如下图所示:\n\n免疫证需要去政府指定的动物医院，政府指定的动物医院可以去政府网站查看，或者直接拨打当地的卫生所，也能查询到。办了免疫证后，还需要在当地接种疫苗。\n有了免疫证且接种完疫苗后，就可以去当地卫生所办理检疫合格证明：\n\n有几个时间点需要注意：\n\n疫苗生效需要2周\n检疫合格证明有效时间只有5天\n\n航空公司受理买机票的时候，去航空公司官网查询哪些航班提供了有氧舱，或者直接拨打航空公司的服务热线电话也行。\n我托运的是使用的国航，拨打电话后，先预定好有氧仓位，2个小时内预定机票即可。预定和成功锁定仓位后，都会有邮件通知。\n需要自行打印一个预定申请书，并在登机时携带。\n\n有了有氧仓位后，需要将宠物装进航空专用的宠物箱内，箱内可以放置一些水源和布料。\n到了起飞那天，需要比往常提前40分钟左右到前台，带着检疫证明和预定申请书办理宠物托运。\n航空公司会给箱子进行进一步处理，包括用网绳加固，打包处理等等。需要收取一定的服务费用，我记得在30左右。\n宠物托运的价格，跟宠物的重量有关，国航的计价规则是体重(kg)*1.5%票面价格，我花费了200左右。\n飞机到达目的地后，需要在拿去包裹的地方等待宠物。宠物属于特殊包裹，会有专人运过来，等待时间在15分钟左右。\n整个过程，花花没有感觉到不适，运输前尽量少给宠物喂食。\n加急下的应急方案部分店家会提供托运服务，有高铁和航空。如果等不了2周办理免疫证的，他们也有渠道，安全性不可知，费用普遍在500左右，谨慎选择。\n","tags":["Life"]}]