<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="ANATAS LUO"><title>内核程序员的自我修养 | Anatas Luo&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"anatasluo.github.io",root:"/",language:"zh",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:"enable",expand_all:!1,init_open:!1},style:{primary_color:"#0066CC",avatar:"/images/avatar.png",favicon:"/images/favicon.ico",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:null,description:"六朝何事 只成门户私计"},scroll:{progress_bar:{enable:!0},percent:{enable:!1}}},local_search:{enable:!0,preload:!0},code_copy:{enable:"enable",style:"default"},pjax:{enable:!0},lazyload:{enable:!1},version:"3.4.2"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">Anatas Luo&#39;s Blog</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">内核程序员的自我修养</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">ANATAS LUO</span> <span class="author-label">苏拉</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2020-06-05 11:05:11 </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Programmer/">Programmer</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3.1k 字</span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="技术方向选择的困惑"><a href="#技术方向选择的困惑" class="headerlink" title="技术方向选择的困惑"></a>技术方向选择的困惑</h2><p>作为一个计算机科学专业出身的学生来说，有个问题一直困扰着我。那就是，我应该学习什么。学校教授给我的课程覆盖了方方面面，语言方面就涵盖C语言，Python，C++，Java，更不要提游戏设计，网站设计此类的课程。课程体系覆盖的面很广，但是缺少深度和难度。我需要找一个方向，深耕下去。构建完整知识体系的同时，也能在某个领域有深刻的见解。</p><p>根据知识体系和兴趣，我考虑过以下几个方向：</p><ol><li>前端，技术栈围绕nodejs和angular构建</li><li>后端，技术栈围绕Golang构建</li><li>信息安全，准确点来说，是网络安全</li></ol><h3 id="nodejs相关的前端"><a href="#nodejs相关的前端" class="headerlink" title="nodejs相关的前端"></a>nodejs相关的前端</h3><p>大二暑假的时候，我在Coursera上接触了一门<a class="link" target="_blank" rel="noopener" href="https://www.coursera.org/specializations/full-stack-react#about">全栈课程<i class="fas fa-external-link-alt"></i></a>，在后面的相当长的一段时间内，我都围绕着第一方向，构建自己的技术栈。参加过一些软件比赛，拿过一些奖，甚至实习都是做的前端开发，尽管是vue相关的。秋招过程中，学长看过我简历后，认为我更适合后端，当时没有仔细考虑学长的建议，颇为后悔。</p><p>现在来看，围绕这个思路，这个成长过程存在以下问题</p><ul><li>我对前端的理解，始终停留在解决问题的思路上，我能很快接受新知识，并且利用这些知识解决自己的问题，但是从来没去系统学习过。我没了解过JS的闭包，对浏览器的渲染过程知之甚少，诸如此类。</li><li>后续的成长过程中，我的兴趣更偏向于设计和美工，失去了探索前端技术本身的动力，而且对JavaScript的设计哲学和理念也不是很认同，逐步丧失了成长的基础。</li></ul><h3 id="golang相关的后端"><a href="#golang相关的后端" class="headerlink" title="golang相关的后端"></a>golang相关的后端</h3><p>意识到这个问题的时候，已经是实习结束，处在大三的末尾了，我很清楚，我不会把前端作为我的方向，开始寻找其他可能。恰好这个时候，golang作为一门新语言，正在强势崛起，实习的时候因为业务需要，也有所接触。我意识到，这门语言的前景十分广阔。因此，就有了后来的<a class="link" target="_blank" rel="noopener" href="https://github.com/anatasluo/ant">ant<i class="fas fa-external-link-alt"></i></a>项目，这也是我的毕业设计。我结合自己的前端优势，通过项目加深了对golang的学习，在Github上小有收获。对我来说，是个很大的鼓励。后面的很长一段时间，我也在坚持学习golang相关的东西。整体上来说，这个方向要比前端有吸引力的多，包括兴趣的吻合，实际的收益等等。</p><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p>会想到做信息安全，是因为大学时候我是打ACM出身，也了解过一些CTF的知识。刚接触的时候，给我打开了新世界，这是一种直观表现计算机水平的方式，不仅是对内行人展示，更重要的是对外行人展示。每个男孩子都有一个侠客梦想，我在相当长的一段时间内，在CTF上投入了很多精力。小有收获，但是专业性却十分欠缺。毕竟，我既不是信息安全专业出身，也找不到足够的人跟我一起参考正式的CTF比赛，属于玩票兴致，找工作几乎没指望。</p><h2 id="内核工程师"><a href="#内核工程师" class="headerlink" title="内核工程师"></a>内核工程师</h2><p>时间节点来到毕业前，尽管因为对技术方向的错误选择，让我在nodejs上浪费了大量精力，但是却培养了我对Linux的兴趣。自己写网站，就需要自己去搭建网站，维护网站服务器，数据库服务器等等。这里面遇到的奇奇怪怪的问题，都需要自己去解决，无形中让我有了一定的运维基础。</p><p>对Linux的兴趣，进一步培养了我对开源的兴趣，以致于后来了解到GNU运动，更是一发不可收拾。因此，在秋招拿到来自一个参与操作系统内核开发的机会时，我就毫不犹豫的选择了，尽管那时我都不知道什么是内核开发，以及内核开发要做什么。但是，这个听起来就很酷。</p><p>经过一年时间的快速学习，作为内核工程师，我收获很多，我对编译链接，二进制，内核的调度等等都有了长足的掌握。但是，这个问题仍然困扰着我，那就是 —— 我应该如何深入。在后面的行文中，我将尝试解决以下问题：</p><ul><li>什么是内核工程师</li><li>内核工程师的技术栈构建</li></ul><h3 id="什么是内核工程师"><a href="#什么是内核工程师" class="headerlink" title="什么是内核工程师"></a>什么是内核工程师</h3><p>一般来说，很少有机会去让我们写一个内核。原因很多，首先，内核是个很复杂的东西，不仅仅在于代码规模，更在于内核对代码质量要求很高，需要开发者的素养很好。其次，计算机体系结构近些年的发展缓慢，内核没什么新的技术发展，开源世界的Linux在大多数情况下，就是最经济实用的解决方案。因此，在几乎大多数语境下，内核工程师，就是指的Linux内核工程师，这些人中，有一部分专注于驱动开发，有一部分专注于性能优化，也有一部分做虚拟化之类的东西，总之，都需要对Linux内核机制有很深的理解。</p><h3 id="内核的起源-–-贝尔实验室"><a href="#内核的起源-–-贝尔实验室" class="headerlink" title="内核的起源 – 贝尔实验室"></a>内核的起源 – 贝尔实验室</h3><p>因为内核涉及的东西实在太宽泛了，作为内核工程师，从何处开始积累，这个问题困扰了我相当长的一段时间。在开始解释这个问题前，我想先讲一群人 —— 贝尔实验室。</p><p>贝尔实验室(Bell Labs)是当时的通信业巨头AT&amp;T的一个研发机构，贝尔实验室的肯·汤普逊(Ken Thompso)、丹尼斯·里奇(Dennis Ritchie)、道格拉斯·麦克罗伊(Douglas McIlroy)于1969年开发出了unix内核。为了完成unix的开发，他们于1967年左右设计出了BCPL语言，在1970年，进一步发展出了C语言。1979年，同样供职贝尔实验室的比雅尼·斯特劳斯特鲁普(Stroustrup)，受当时流行的程序语言Simula、ALGOL 68、Ada、ML等影响，开发出了C with class。这门语言，既保持了C语言的底层支持优势，也吸取了OOP的开发效率优点，这门语言于1983年改名为C++。</p><p>从C语言到unix内核，再到C++的出现，这三者可以说是紧密联系，相辅相成的。unix内核的发展，为后续很多内核的出现提供了蓝本，相当多的理念都被其他内核吸收，并进一步发扬光大。</p><p>在长时间的C语言开发过程中，我深刻体会到作为底层语言的C语言，相比于纯OOP的Java语言，开发效率的底下，设计模式的单一。尽管Linux内核仍然采取C语言编写，但是在内核的开发过程中，出现了相当多的伪OOP的用法。比如一union类型中，放置不同类型的成员变量，根据type字段，将union解释成不同的类型。在我看来，这就是一种最原始的继承实现。后来，看了<em>Inside the C++ Object Model</em>，发现早期的C++就是用C这么实现的。C++对于内核的开发可能过于复杂(要不然也不会一直使用C开发内核)，但是C++相当多的特性，确实是一种开发效率上的长足进步。因此，C++的出现是一个很自然的事情，倒不如说，C++在保持对C相当兼容的同时，仍然支持OOP，无论如何都是一个非常惊艳的设计。</p><p>当然，由于C++过于复杂的特性，使得开发人员困苦不堪，在2007年左右，肯·汤普逊又参与开发了一门新语言的设计，也就是后来的golang。</p><h3 id="内核技术栈"><a href="#内核技术栈" class="headerlink" title="内核技术栈"></a>内核技术栈</h3><p>在对编程语言的掌握上，包括:</p><ul><li>C语言<div style="text-indent:0;padding:2em">C语言相对来说，是一门比较容易的语言。但是实际使用过程中，需要对编译器的方方面面都有所了解，才能对内核的行为有充分的掌握。</div></li><li>C++<div style="text-indent:0;padding:2em">对C++的学习，不单单能写出更优雅的C语言，早期的C++就是编译成C语言实现的，更重要的是，OOP已经发展成了编程语言中主流，对C++的掌握，也能对设计模式，异常处理等等一窥全貌，培养更深的兴趣。</div></li><li>golang<div style="text-indent:0;padding:2em">golang为了弥补C和C++的不足而出现，同样出自肯·汤普逊之手，处在快速崛起的时期，未来的潜力不可估量。</div></li></ul><p>总之，这三门语言血脉相连，有着相同的历史传承，设计上也有诸多相似之处，学习起来可以相互映照，相辅相成。既能对底层的世界一窥究竟，也能培养出对上层世界的兴趣。</p><p>在对基础学科的掌握上，包括:</p><ul><li>汇编语言</li><li>编译原理</li><li>编程语言</li><li>操作系统</li><li>设计模式</li><li>软件工程</li></ul><p>从汇编语言到编译原理，再到编程语言。都是为了讲清楚，底层世界是如何一步步构建起来的，以及构建过程中最重要的工具 —— 编程语言，是如何设计的。操作系统，则是在此基础上，为上层世界构建运行环境，因为操作系统通常又可以被称为”软硬件接口”。再往上，设计模式和软件工程，就是讲如何在操作系统构建的环境之上，进一步高效的构建应用。到这里，整个计算机世界，就都被串联起来了。当我写下“class A {};”的时候，我很容易就能想到，最后这串代码在内存的模型是什么样的，编译成的汇编又会是什么样的，这是一件尽在掌握中的满足感。</p><h3 id="技术栈展开"><a href="#技术栈展开" class="headerlink" title="技术栈展开"></a>技术栈展开</h3><p>编程语言和基础学科的学习过程，是相互促进的，不存在严格的先后关系，下面整理了我当前以及后续学习过程使用的材料。</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>书籍：</p><ol><li>C++ Primer(第五版)</li><li>Inside the C++ Object Model</li><li>STL源码剖析(侯捷著)</li><li>Effective C++</li><li>More Effective C++</li></ol><p>网站：</p><ol><li><a class="link" target="_blank" rel="noopener" href="http://www.stroustrup.com/bs_faq2.html">Bjarne Stroustrup’s C++ Style and Technique FAQ<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://bestcbooks.com/recommended-cpp-books/">计算机书籍控<i class="fas fa-external-link-alt"></i></a></li></ol><p>概念和问题：</p><ol><li>C++的特性能用C来实现吗，如果可以，如何实现</li><li>C++的历史发展和新特性(C++11)</li></ol><h4 id="汇编语言、编译原理和编程语言"><a href="#汇编语言、编译原理和编程语言" class="headerlink" title="汇编语言、编译原理和编程语言"></a>汇编语言、编译原理和编程语言</h4><p>书籍:</p><ol><li>汇编语言(王爽著)</li><li>Understanding Programming Languages</li></ol><p>概念和问题：</p><ol><li>汇编和C语言的调用接口和规范 – AACPS(ARM中的规范)</li><li>当前的主流编译器实现，他们之间的区别</li><li>什么是IR</li><li>如何评价一门编程语言，不同语言间如何比较</li></ol><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>概念和问题：</p><ol><li>当前主流内核之间的联系和发展历程</li><li>对内核最深入的一个模块</li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这篇博客，看起来更像是我学习过程中的一个书单。当我看到贝尔实验室这段发展历史的时候，整个思路豁然开朗。无论是什么学科，对于学科历史的了解都是十分必要的，这些历史，解释了这门学科为什么发展成这样，以及解释了未来可能会是什么样。作为一个内核工程师，我沿着这群人的步伐，从底层的机器语言世界，到上层的设计模式，整个计算机世界都自然的在我眼前展开，这既让我满怀欣喜和期待，又十分忐忑畏惧。总之，这是一个很好的进展，我对于我将沿着这一道路深信不疑。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%2B%2B">C++维基词条<i class="fas fa-external-link-alt"></i></a></li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：内核程序员的自我修养</li><li>本文作者：ANATAS LUO</li><li>创建时间：2020-06-05 11:05:11</li><li>本文链接：https://anatasluo.github.io/2020/06/05/内核程序员的自我修养/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2020/06/11/Empty-struct-class-in-C-C/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">Empty struct/class in C/C++</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2020/02/14/note-%E7%90%86%E8%A7%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="title flex-center"><span class="post-nav-title-item">[note]理解编程语言</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">ANATAS LUO</a></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9%E7%9A%84%E5%9B%B0%E6%83%91"><span class="nav-number">1.</span> <span class="nav-text">技术方向选择的困惑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nodejs%E7%9B%B8%E5%85%B3%E7%9A%84%E5%89%8D%E7%AB%AF"><span class="nav-number">1.1.</span> <span class="nav-text">nodejs相关的前端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#golang%E7%9B%B8%E5%85%B3%E7%9A%84%E5%90%8E%E7%AB%AF"><span class="nav-number">1.2.</span> <span class="nav-text">golang相关的后端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="nav-number">1.3.</span> <span class="nav-text">网络安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="nav-number">2.</span> <span class="nav-text">内核工程师</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="nav-number">2.1.</span> <span class="nav-text">什么是内核工程师</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E8%B5%B7%E6%BA%90-%E2%80%93-%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4"><span class="nav-number">2.2.</span> <span class="nav-text">内核的起源 – 贝尔实验室</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="nav-number">2.3.</span> <span class="nav-text">内核技术栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E6%A0%88%E5%B1%95%E5%BC%80"><span class="nav-number">2.4.</span> <span class="nav-text">技术栈展开</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C"><span class="nav-number">2.4.1.</span> <span class="nav-text">C++</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">2.4.2.</span> <span class="nav-text">汇编语言、编译原理和编程语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.4.3.</span> <span class="nav-text">操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E5%B0%BE"><span class="nav-number">3.</span> <span class="nav-text">结尾</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/code-copy.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1});document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),e.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>